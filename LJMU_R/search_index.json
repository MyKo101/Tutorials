[["index.html", "Statistics In R Statistics in R", " Statistics In R Michael A Barrowman m.a.barrowman@ljmu.ac.uk 2020-11-26 Statistics in R Welcome to the Lecture Notes for the Statistics in R course, brought to you by the Academic Skills Team at LJMU. This course is currently constructed as 5 chapters and will be presented as 1.5 hour sessions each. Please use the contents list on the left to browse through the notes. You can expand or minimise the contents by clicking the three bars () in the top left. "],["introduction-to-r.html", "1 Introduction to R 1.1 R &amp; RStudio 1.2 Data Types 1.3 Help 1.4 Vectorisation 1.5 Statistics 1.6 Probabilities", " 1 Introduction to R 1.1 R &amp; RStudio 1.1.1 R R is a programming language that is designed to work quickly and efficiently with large amounts of data, this is done through the unique way it processes this data. It is open source, meaning that other people from around the world can easily contribute code that you can use through add-ons, known as packages. Another reason for Rs popularity is that it (and the applications that run it) are free and the support online (from other ordinary users) is incredibly helpful. 1.1.2 RStudio If you try to download R directly, you will also download a program called RGui. This is the default program for running R code. For what it does, RGui is fine. But we dont want fine, we want GREAT! So were going to use another program called RStudio. RStudio organises your workspace a little bit better than the default RGui and allows for better interacticve help features which well discuss later. Below is an example of what RStudio should look like. The screenshot shows the four panes that we usually work with. Top-Left shows the Script, which is the code file were currently working in. Code written here wont be run immediately, but it allows us to save code to be re-run later. Bottom-Left shows the Console, code written here will be run, so be careful what you type here. Top-Right is the Workspace, which shows the variables/data that RStudio is storing for us and that we can use. Bottom-Right shows the Viewer, which primarily displays Plots and Help. Of course there is a lot more going on here, but for the most part, these are the important bits. Remember: R is the language and RStudio is the application, but you cant use RStudio without R! (That said, Im probably going to use the two interchangeably throughout) 1.1.3 Where to get them? When youre using an LJMU computer, you can search for RStudio in the LJMU Application Player to download it. This course is designed for use with RStudio 64 (with the circular logo). Elsewhere, you can download it from their webpage. As mentioned above, RStudio is free and will automatically install R as well. 1.1.4 First steps When you first open RStudio, what you see wont be like the screenshot. Thats because there is no Script open and so the Console fills the entire left side. Its also filled with some information regarding licencing and the version of R you are currently running. The first step in RStudio is to create a new script. Go to File &gt; New File &gt; R Script (or press Ctrl + Shift + N on Windows or Cmd + Shift N on Mac). The Script pane should now appear with a tab called Untitled 1. In the Console pane, type 2+2 and hit Enter. 2+2 ## [1] 4 RStudio just ran the code immediately. The [1] here just means that the 4 is the first result from what R has calculated (well get on to that in a bit). Next, with the Console still selected, press up and RStudio will recall the previously run line of code. and you can change the code and you run it again 2+3 ## [1] 5 This time, in the Script pane, type pi+1, hightlight it and press Ctrl + Enter (or Cmd + Enter on Mac). pi+1 ## [1] 4.141593 This will automatically transfer the code into the Console and run it. Importantly, however the code is still in the Script pane, ready to be edited and/or used again. Congratulations! You just did some coding! 1.2 Data Types Within R, and many other programming languages, we have different types of data. Here Im going to quickly run through the three basic ones that youre likely to encounter, and as the course goes on Ill introduce a couple more. But before I can do that, we need to discuss variables 1.2.1 Variables Most of what we do in R is to create and store data in variables, for us to use later. Here were going to create a variable, called x and store a value inside x &lt;- 2 The &lt;- symbol is called the assignment operator and it assigns the value of 2 to the variable x. Typing this into the Console and running it (or into the Script and executing it) doesnt appear to do much. However, if we look in the Environment Pane, we can see that its now been populated with a table that says x and 2. This gives us the name of our variable and the value stored within it. You can think of these as boxes with labels. We can interact with whats in the box, by referring to its label. For example x + 2 ## [1] 4 Looks in the box labeled x, pulls out its value, 2, adds 2 to it and then outputs the result, just like before. In fact, earlier we used a variable called pi, which is by default assigned the value of 3.141592... 1.2.2 Numeric Data The most common kind of data we can use is numeric, and this is what weve just made. We created x as a numeric variable with the value of 2. With numeric data, we can perform the standard mathematical operators as you would expect: Symbol Description + Adds two values together * Multiplies two values together - Subtracts one value from the other / Divides one value by the other ^ Takes one value to the power of the other Addition, multiplication, division, subtraction and exponentiation. We also have comparitors to check the relationship between two values: Symbol Description == Checks if two values are equal != Checks if two values are not equal &lt; Checks if one value is smaller than the other &lt;= Checks if one value is smaller than or equal to the other &gt; Checks if one value is larger than the other &gt;= Checks if one value is larger than or equal to the other In order, these check whether two values are equal, not equal, less than, greater than, less than or equal to and greater than or equal to. For example, we can run the following code ad get an appropriate outputs: x == 2 ## [1] TRUE x &gt; 4 ## [1] FALSE This leads us to our second data type 1.2.3 Logical Data Logical, or binary, data consists of TRUE or FALSE statements. The above values can actually be stored into variables using the assignment operator y &lt;- x == 2 z &lt;- x &gt; 4 y ## [1] TRUE z ## [1] FALSE Logical data has its own group of logical operators, which are different to the above ones: Symbol Description &amp; And - Are they both TRUE? | Or - Is one of the TRUE? ! Not - Negates the value For example, we can combine the values of y &amp; z above like so: y &amp; z # Are they both TRUE? ## [1] FALSE y | !z #Is y TRUE or is z FALSE? ## [1] TRUE 1.2.4 Character Data Characters consist of all the other symbols we use and when they are combined, they are known as a string. To create a string in R, we wrap it in quotation marks x &lt;- &quot;hello&quot; Note that when we run the above, the value of x in our Environment pane has now changed to match this new value. With characters, youve got to be a little wary asit can be very easy to get your strings and your numerics mixed up. For example, the following throws an error: &quot;2&quot; + &quot;3&quot; ## Error in &quot;2&quot; + &quot;3&quot;: non-numeric argument to binary operator A lot of the time, character and string are used interchangeably, but to be specific, a character is a single symbol, whereas a string, well, a string of them. Unfortunately, there arent any operators that act on characters, however we have plenty of Functions that do. Well come back to functions soon, but know that they form a core part of coding in R. They take inputs, called arguments or parameters and provide us with outputs. A common function is the paste() function which can be used on strings: paste(&quot;Hello&quot;,&quot;World&quot;) ## [1] &quot;Hello World&quot; The comma here indicates that we are providing two arguments to the function. The first is the character string Hello and the second is World, the paste() function sticks these two together to form a new, single string Hello World, notice how it also adds a space between these two strings. 1.3 Help 1.3.1 Help Files For any problem you might have, your first port of call in RStudio is the ? symbol. The easiest way to get help is to type a question mark followed by the name of the function that you want to know more about and help will pop up in the Viewer pane ?mean 1.3.2 Search Next port of call should be Google/Ecosia/Bing or whatever your Search Engine of choice is. If you have a question that you need to know, type in R and then just ask that question to your search engine. I dont mean try to phrase it in a certain way, I mean write the question exactly how you would ask it! When you search for something, a lot of results will probably be tutorials on how to do what youre trying to do. If what youre asking is a common question, these will be good resources. For more unusual questions, Stack Exchange is the most reliable forum for R answers. It is full of users who are more than willing to answer your difficult questions (some of them even enjoy it!) 1.3.3 Ask Surprisingly enough, Statisticians love Twitter. If you have a question, just post it with the #RStats hashtag and youll probably get some reasonable responses. Or tweet it with #LJMU_MSIT and I will either reply or retweet it to more stats people. Finally, the Maths, Stats &amp; IT Team run regular Drop-In Sessions and One-To-Ones which youre more than welcome to come by to. Just check out the Library Calendar to find a suitable session. Remember, never feel like youre asking a stupid question. If you dont know the answer, just ask! 1.4 Vectorisation 1.4.1 Vectors In mathematics, a vector is usually a set of ordered numbers which can be used to represent a point in 2/3D space. However, R uses vectors in a slightly different manner to essentially mean a list of data (although a list is a different thing in R). I can create a vector in R by using the c() function and passing some numbers as arguments, separated by a comma. c(1,2,3) ## [1] 1 2 3 I can also create a vector out of characters, or logical data: c(&quot;hello&quot;,&quot;world&quot;) ## [1] &quot;hello&quot; &quot;world&quot; c(TRUE,FALSE) ## [1] TRUE FALSE Notice that this time, the hello and world are shown to be seperate, rather than earlier when they were a single string. This is because weve turned these into vectors of length 2. The c() function will probably be one of your most used functions, which is why its name is so short. It keeps it easy to use. Vectors in R have to be the same data type. You cant create a vector that is part numeric and part character. If you try, R will try to convert things to the same type. c(&quot;hello&quot;,2) ## [1] &quot;hello&quot; &quot;2&quot; See how this has converted the 2 into \"2\", which as weve discussed is viewed very differently by R. This is called coercion and can cause errors if youre not careful. You can also use c() to combine vectors into bigger ones, or to add values to the beginning or end of another vector x &lt;- c(2,4,6) y &lt;- c(8,10) x &lt;- c(x,y) Functions dont always need arguments though, as the below function can run fine and gives us the current time. Sys.time() ## [1] &quot;2020-11-26 17:36:54 GMT&quot; But the key to remember is that a function has brackets () right after its name. And, a word of warning, R is Case Sensitive. This means you need to be careful that you use upper and lower case appropriately. sys.time() ## Error in sys.time(): could not find function &quot;sys.time&quot; Weve now created a vector of numbers but weve not done anything with these numbers. What is happening here: c(1,2,3) + 10 ## [1] 11 12 13 Here, we created a vector of numerics, and then performed an operator on that vector. R did this for each individual element of our vector. This can also work with vectors that are the same length: c(1,2,3) + c(1,2,3) ## [1] 2 4 6 One last operator that weve not mentioned yet is the sequence operator, :. This operator works with numbers to create a vector that runs from the first number to the second and is very useful for quickly creating big vectors. 1:100 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ## [19] 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 ## [37] 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 ## [55] 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 ## [73] 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 ## [91] 91 92 93 94 95 96 97 98 99 100 This also demonstrates what the [1] meant earlier. The element next to it is the first element. The next row here, shows [19], which means that 19 is the nineteenth element, and so on. This makes it easier, if youre dealing with large data, to pinpoint where something might be wrong. Try running the code 1:1000 (either in the Console or the Script pane). What do you think is happening here? length(1:1000) ## [1] 1000 what happens if you run the code length(1:(10^6))? And what about length(1:(10^15)). Try length(1:(10^16)) ## Error in 1:(10^16): result would be too long a vector R doesnt even try it. R knows its limits But it can make it up to 1015, which means that R created a vector that was 1015 elements long before figuring out its length. And it did it really quickly (because R is good with vectors) 1.4.2 Subsetting As previously shown, data can be assigned to a variable, this includes vectors. x &lt;- c(2,4,6,8,10) Looking up at the Environment pane again, were told its data type (this time its an int), and its length is 5 from the [1:5]. When were working with vectors, sometimes we need to grab out just some of the elements and not all of them. For this, we use subsetting or extraction. If we want to pull out the third element of a vector, we enclose that number in square brackets, [ and ], to tell R that we are extracting data from a vector: x[3]. We can also pass a vector into the subsetting to grab more than one element: x[c(1,2,3)] ## [1] 2 4 6 And, since we can pass in a vector, think about what the following does. x[1:3] ## [1] 2 4 6 The next easiest way to subset is to use a logical vector that is the same length as the vector we are subsetting, and R will return any element which is TRUE and ignore elements which are FALSE. x[c(T,T,F,F,T)] ## [1] 2 4 10 y &lt;- c(&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;,&quot;green&quot;,&quot;red&quot;) x[y==&quot;red&quot;] ## [1] 2 10 Finally, we can also subset to remove elements were not interested in x[-3] ## [1] 2 4 8 10 x[-c(2,3)] ## [1] 2 8 10 Assignment and Subsetting can also be combined to change certain elements in our vector x[3] &lt;- 2 x ## [1] 2 4 2 8 10 x[4:5] &lt;- 0 x ## [1] 2 4 2 0 0 If we have a patrticularly large vector, we can also look at just the first 6 values, by using the function head() (or conversely, tails() to show us the last 6), as well see in the next section. Do you see what the [1:5] means in the Workspace pane? The 1:5 is the possible values that we can subset x with. 1.5 Statistics 1.5.1 Data Now that we have the basics, we can move onto some statistical work using data. Normally, you would use a function such as read.csv() to read in our data. This function can read in data that is formatted as a csv file (or comma-separated). There are also ways to import more complicated data, such as from excel, but these dont come built-in with R (we need additional stuff called packages to load other data). An important note when loading data using read.csv() or a similar function is that the file directory needs to use forward slashes (/) rather than backward slashes (\\). Basically, copy the folder directory, but replace the slashes: dat &lt;- read.csv(&quot;M:\\Documents\\My Data.csv&quot;) # This line won&#39;t work dat &lt;- read.csv(&quot;M:/Documents/My Data.csv&quot;) # This works! Thats how you get your data into R. Today, were going to begin by loading up a built in dataset, called iris, which is a dataset containing data about flowers. data(&quot;iris&quot;) head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa The function data() can be used to load up a Built-in datasets (useful for examples and practising!). As previously said, head() now displays the first 6 rows of our data, which is a table (known in R as a data.frame). Double click on iris in the Environment and a new tab will open up in place of the Script pane. This shows the full table and allows us to scroll. There are five variables in iris: Sepal.Length, Sepal.Width, Petal.Length, Petal.Width and Species (note the capitalisation!). Similar to a vector, we can subset in a data.frame using the square brackets, however since iris is a table, R needs two values, one for the row and a second for the column, separated by a comma (again, we can extract multiple rows/columns by using vectors) iris[2,3] #Returns the value in the second row and the third column ## [1] 1.4 iris[1:10,1:3] #Returns the values in the first ten rows and the first three columns ## Sepal.Length Sepal.Width Petal.Length ## 1 5.1 3.5 1.4 ## 2 4.9 3.0 1.4 ## 3 4.7 3.2 1.3 ## 4 4.6 3.1 1.5 ## 5 5.0 3.6 1.4 ## 6 5.4 3.9 1.7 ## 7 4.6 3.4 1.4 ## 8 5.0 3.4 1.5 ## 9 4.4 2.9 1.4 ## 10 4.9 3.1 1.5 iris[1:5,c(3,4,5)] #Returns the first five rows and the 3rd, 4th and 5th columns ## Petal.Length Petal.Width Species ## 1 1.4 0.2 setosa ## 2 1.4 0.2 setosa ## 3 1.3 0.2 setosa ## 4 1.5 0.2 setosa ## 5 1.4 0.2 setosa The way R structures data.frames is that each variable within the data.frame is its own vector of values with the restriction that all the vectors have to be the same length, i.e. the number of rows in the table. Which means, we can pull vectors out using the $ operator: iris$Sepal.Length #Notice that RStudio pops up with the available variable names here ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 ## [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0 ## [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 ## [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1 ## [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5 ## [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 ## [109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2 ## [127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 ## [145] 6.7 6.7 6.3 6.5 6.2 5.9 And these vectors can be used in the exact same way as other vectors, e.g iris$Sepal.Width[1:15] ## [1] 3.5 3.0 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 3.7 3.4 3.0 3.0 4.0 As previoiusly, we can also edit individual values (known as cells) within a dataset using the subsetting and assignment. 1.5.2 Describing our data Here are a few functions that can be useful for describing your data: mean(iris$Sepal.Length) #Gives the arithmetic mean of the variable Sepal.Length within the data.frame iris ## [1] 5.843333 sd(iris$Sepal.Width) #Standard Deviation of the variable ## [1] 0.4358663 table(iris$Species) #Provides a count of each unique value of the variable ## ## setosa versicolor virginica ## 50 50 50 range(iris$Petal.Length) #Gets the minimum and maximum values, these can also be extracted using min() and max() ## [1] 1.0 6.9 If we want to find out the median and/or percentiles of a variable we use the quantile() function, and we can specify which percentiles we want to find in the vector. We do this by specifying the percentiles as decimal values (i.e. between 0 and 1) in another vector and pass both arguments to the function. Once again, remember we separate arguments by a comma. Quantiles &lt;- c(0.05,0.5,0.95) quantile(iris$Petal.Width, Quantiles) ## 5% 50% 95% ## 0.2 1.3 2.3 We did not need to define Quantiles beforehand here, but it certainly makes the code look a little neater than this: quantiles(iris$Petal.Width,c(0.05,0.5,0.95)). We can also combine subsetting to pull out descriptive statistics based on pre-requisites. What does this do? mean(iris$Sepal.Length[iris$Species == &quot;setosa&quot;]) ## [1] 5.006 From Rs perspective: Create a logical vector that is the same length as the vector iris$Species (i.e. same as the number of rows in the table), to indicate whether iris$Species == \"setosa\" Pull out the subset of iris$Sepal.Length such that the previous vector is TRUE Calculate the mean of this vector. R works from the inside outwards when it comes to functions like this. Not the most legible way to understand the code afterwards (but well learn how to fix this next week!) 1.5.3 Plotting The basic function for plotting in R is the plot() function, and is used very intuitively for scatter plots: plot(iris$Sepal.Length,iris$SSepal.Width) However, this is pretty boring. Lets add some colour and give appropriate labels plot(x = iris$Sepal.Length, y = iris$SSepal.Width, col = iris$Species, main = &quot;Plot of Sepal Length vs Width&quot;, sub = &quot;Stratified by Species&quot;, xlab = &quot;Sepal Length&quot;, ylab = &quot;Sepal Width&quot;, ) Here, we changed the plot to use the variable Species as an indicator of which colur to use for each point. We could have just used col=\"red\" to tell R to plot them all red, but thats not as useful to distinguish! Weve done something new here, we supplied our arguments to the function as a named argument. This is because not all of these arguments are needed (see the previous one). If we dont name them, R assumes the first argument is x and the second is y (which is a good assumption to make). However, since theyre not needed, we need to tell R which is which (it cant rely on them being supplied in the same order everytime). If we dont specify them, R will choose default values, which can be seen in the help file (?plot). 1.6 Probabilities 1.6.1 Data Distributions Now that we can plot, it means we can visualise a key aspect of statistics: the probability density function (pdf) and the cumulative density function (cdf) of a probability distribution.To demonstrate, Im going to use the Normal distribution. The Normal distribution is one of the most commonly used distributions due to its symmetry and the fact that many natural variables can be modelled by it. The Standard Normal distribution is when the values have been standardised so that the mean is 0 and the sd is 1. 1.6.1.1 Density Function x &lt;- seq(-3,3,0.01) #Create a vector form -3 to 3 with steps of 0.01 y &lt;- dnorm(x, mean=0, sd=1) #Here is the new function plot(x, y, type=&quot;l&quot;,ylab=&quot;Density&quot;) # The argument type = &quot;l&quot; means we want a line plot The function dnorm is the probability density function (pdf) for the Normal distribution, usually written as \\(f(x)\\). Higher density means more values are clustered around there and a lower density means there are less. the two arguments, mean and sd can be defined to match our data. For the Standard Normal, the pdf is defined by this nasty looking formula: \\[ f(x) = \\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{1}{2}x^2} \\] Lets say we have a clinical trial with two arms; a control arm and a treatment arm. The treatment arm recieves a drug that may be able to reduce systolic blood pressure (SBP). After the trial is over, we are told that for the control arm, the mean SBP is 160 with an sd of 3 and the treatment arm has an SBP of 155 with an sd of 4. Assuming they are Normally distributed (a fair assumption if we have enough patients), then we can plot the density of the two distributions on the same plot x &lt;- seq(145, 170, 0.1) #Broad range of values to cover both groups control.y &lt;- dnorm(x, mean = 160, sd = 3) #Get the y values for the control arm treat.y &lt;- dnorm(x, mean = 155, sd = 4) #Get the y values for the treatment arm plot(x,control.y,col=&quot;red&quot;,type=&quot;l&quot;,ylab=&quot;Density&quot;,xlab=&quot;SBP&quot;) #Remember what all these arguments do? lines(x,treat.y,col=&quot;blue&quot;) #the lines() function *adds* a line to a previous plot Loooking at the two plots, there is a lot of overlap so it would be difficult to say that this drug works. What happens if you change the mean or sd for either of the arms? 1.6.1.2 Probability Function x &lt;- seq(-3,3,0.01) y &lt;- pnorm(x, mean=0, sd=1) plot(x, y, type=&quot;l&quot;,ylab=&quot;Probability&quot;) The function pnorm is the cumulative density function (cdf), usually written as \\(F(x)\\). It is defined as the area under the pdf up to the value (i.e. its integral). It is used to find the probability that something is less than that value (assuming it follows a Normal Distribution). \\[ F(x) = \\int_{-\\infty}^x f(u) \\;\\textrm{d}u = \\textrm{Prob}\\left(X &lt; x\\right) \\] This can answer questions such as: If we assume the height of males at a university follows a Normal distribution with a mean of 175.5cm and a standard deviation of 6.5cm. What is the probability that a male student chosen at random is taller than 180cm? p &lt;- pnorm(180, mean = 175.5, sd = 6.5) #This is the probability that a student is *shorter* than 180cm 1 - p #The probability that they are *taller* than 180cm ## [1] 0.2443721 1.6.1.3 Quantile Function p &lt;- seq(0,1,0.01) #This time, we need the input to be between 0 and 1 y &lt;- qnorm(p,mean = 0, sd = 1) plot(p,y,type=&quot;l&quot;) The function qnorm() is the inverse of the pnorm() function. For a given probability, it can provide the associated value. From the previous example, what height are 95% of the students shorter than? p &lt;- 0.95 qnorm(p, mean = 175.5, sd = 6.5) ## [1] 186.1915 So 95% of the male students in the school are shorter than 186.2cm. 1.6.1.4 Random Function z &lt;- rnorm(100, mean = 0, sd = 1) head(z) ## [1] -0.4388359 -0.5140361 -0.3403129 -1.3635764 -1.0183984 0.0475579 If you were to print out the z variable, youd see 100 random numbers. The first argument we pass to the function rnorm() tells it how many random numbers to generate. These random numbers have been drawn from the Standard Normal distribution and so they will follow that distribution. We can see this with the following plot: hist(z) This histogram shows where all the values in the data in z lie. We group them into bins and then count how many are in each bin. This histogram should roughly look like the pdf of the distribution. However, due to the random nature and the fact that there are only 100, its not very close to its underlying distribution. If we increase the number of random numbers to 10,000, itll look closer. z &lt;- rnorm(10000) #This time, we&#39;re not specifying the mean or sd for either rnorm or dnorm x &lt;- seq(-3,3,0.01) y &lt;- dnorm(x) # By default, R will use mean = 0 and sd = 1. hist(z, probability = T) #This tells R that we want the probability of each bin, rather than the count (i.e. count/total) lines(x,y) 1.6.1.4.1 Other Distributions So far, for this section, weve used the Normal distribution. However, there is a whole bunch of other distributions that we could use, and they all follow the same formatting style: dxxxx(x,...) gives the probability density function of the distribution at x pxxxx(x,...) gives the cumulative density function of the distribution at x qxxxx(p,...) gives the inverse of the cdf of the distribution at p rxxxx(n,...) generates n random numbers that follow the distribution A few examples can be seen in the below plots: "],["enter-the-tidyverse-verbs.html", "2 Enter The Tidyverse: Verbs 2.1 Introduction 2.2 Packages 2.3 The Pipe 2.4 Tibbles 2.5 One Table Verbs", " 2 Enter The Tidyverse: Verbs 2.1 Introduction In this weeks session, we will discuss Rs add-on mechanic, where we can include packages within our projects and focus on a specific family of packages called the tidyverse 2.2 Packages A lot of computer programs have add-ons that do not come included in the main piece of software. A big (money-making) example of this is downloadable content is video games, whether its a an aesthetic DLC such as a hat in Among Us or new level packs in Call of Duty. But this concept is true for TV bundles, Sky can be subscribed on its own or with Sky Movies or Sky Sports. You could even think of downloading Apps on your phone as additional content since they dont come with your phones OS by default. Or even the video games themselves are additional content for your console. This kind of approach to media is called modular. Modular design has become very popular and is a key aspect of many Open Source pieces of software. Open Source means users can edit the underlying program and it isnt locked in to the official developers. For beginners, it would be highly discouraged to actually do this. But there are R whizzes out there who do this kind of thing. The product of what they do are called packages. Packages are bundles of code that R will load up ready to for you, the user, to use. These mostly consist of new functions and occasionally data, and usually include documentation on how to use the functions and data. The tidyverse is a little different as its a meta-package, which means its actually made up of a few other packages. When we install or load it, its actually installing &amp; loading a few other packages, which is why it can take a while to install. 2.2.1 Installing packages To get a new package, we can use the install.packages() function and supply the name of the package we want as a string: install.packages(&quot;tidyverse&quot;) Packages are generally stored in an online repository called CRAN. When you run install.packages(), R will search CRAN for the package youre trying to install and if it finds it, itll download and install it for you. Its that easy. There are other ways to install packages, but this is the most common and basic. However, just because weve installed it, doesnt mean we can use it yet. To load it up ready to go, we need to use the library() function. This time, we dont need the quotes as R will find the package as it is: library(tidyverse) It also gives us a little bit of information about whats actually happened here. The tidyverse has loaded up all these other packages, e.g. ggplot2, purrr and dplyr. The Conflicts section just means that dplyr has a function called filter(), but so does the stats package. The stats package is loaded when you open R and includes functions like mean() and sd(). Since we loaded dplyr last (as part of tidyverse) if we try to call these functions which have the same names, R will use the ones found in dplyr, rather than those found in stats. The filter() and lag() functions in the stats package dont get used much, so its fine to do this and filter() in dplyr is incredibly useful. This dplyr package is where most of the functions were going to discuss today come from. As well as these packages that have been loaded by tidyverse, there were also some others that were installed, but we dont need them right now and they can stay in the background. 2.2.2 CRAN CRAN stands for Comprehensive R Archive Network. When you installed R in the first place, you would have also installed it from CRAN. When a developer wants to publish a package, CRAN is the main place where they go (although there are others, such as BioConductor or github). The reason being is that its hosted by The R Team and the install.packages() comes built in to R. You dont need anything else to get packages from CRAN. This is an example of what a CRAN page for a package looks like; this is the CRAN page for tidyverse and is a standard layout for CRAN pages. Yes, it looks pretty boring. You can find this page here Most of this screenshot wont actually be very useful to you as R newbies, but there are some key parts. Name - Every package has a Name, here its tidyverse Title - Usually a few words to describe what the package does and is shown after the name on CRAN, here its Easily Install and Load the Tidyverse Description - A paragraph to describe in more detail what the package does, and can include links, etc Version - R package are version controlled and so newer version may not be back compatible. This shouldnt be a problem for you at this point Depends - What other packages does this package require. For example, tidyverse requires the broom package to be installed, and includes which version it needs. The install.packages() function also installs all these dependencies so you dont need to worry about them. Author &amp; Maintainer - The person that wrote and/or manages the package. If you wish to reference a package in your work, you can use this information Citation - CRAN also provides a Citation reference which is compatible with most referencing software Reference Manual &amp; Vignette - Useful Documentation There are of course more things on this page, but most of it isnt particularly useful. The main pieces I wanted to show you are the Reference Manual and the Vignettes 2.2.2.1 Reference Manual Previously, we used the ? operator to bring up help files. R packages also include these help files for the functions that they provide and these are all compiled into a single pdf, which is the Reference Manual. If you want a formal run through of what every function in a package does, this is where you will find it. However, it can be a bit dull and is most useful as a reference (thus the name) 2.2.2.2 Vignettes Vignettes are much more useful for users. They provide a walk-through or guide on how to use this package and will usually include examples of using the package in action. If youre interested in using a new package that youve never used before, this is the place to start. The tidyverse vignettes are more about the structure of the tidyverse, however if we were to look at another, say for dplyr, it walks us through like a tutorial on the best practices with this package. A lot of whats discussed in this vignette will be covered today. 2.3 The Pipe One of the most important things to come with the tidyverse is the %&gt;% pipe operator. The pipe allows us to create simple and smooth workflows. It basically takes whatever is on the left of the operator and passes it to a function on the right. Here are a few pieces of code, using the magrittr package to demonstrate what I mean library(magrittr) ## ## Attaching package: &#39;magrittr&#39; ## The following object is masked from &#39;package:purrr&#39;: ## ## set_names ## The following object is masked from &#39;package:tidyr&#39;: ## ## extract The following three lines of code are equivalent. 2 + 3 #This is using basic operations ## [1] 5 add(2,3) #This uses the `add()` function from magrittr ## [1] 5 2 %&gt;% add(3) # This uses the pipe ## [1] 5 In this toy example, the first version is the simplest, but thats because we have an operator to do addition. If we didnt have this operator (say we were using the mean() function instead), then wed need to do the second version with the add() function. The third shows the same line of code with the pipe. Here we have given the value on the left, 2 as the first argument of add(), and then also supplied the second argument. Here is a much more complicated example: 3*(1 + (2 +3)/5) ## [1] 6 When trying to calculate this, were working from the inside brackets outwards. We first need to figure out which bracket gets evaluated first and work from there. R can do this easily, but it can be tricky for a reader or someone writing this out to not get confused. multiply_by(add(divide_by(add(2,3),5),1),3) ## [1] 6 This problem of figuring out where to start is made even harder when were dealing with functions, rather than operations. Most of the processes we perform in R use functions and so this kind of line is what wed most often be dealing with. Its really confusing. We could simplify it a bit by doing each line of code on a new line and replacing the variable with a new value: x &lt;- 2 x &lt;- add(x,3) x &lt;- divide_by(x,5) x &lt;- add(x,1) x &lt;- multiply_by(x,3) x ## [1] 6 However, this involves a lot of repetition. If we have to type the same thing out over and over again, were very likely to type something wrong. In fact, when writing that example out, I typed it wrong and produced this, can you spot the error: x &lt;- 2 x &lt;- add(x,2) x &lt;- divide_by(x,5) x &lt;- add(x,1) x &lt;- multiply_by(x,3) x ## [1] 5.4 So rather than repeatedly re-assigning a variable, we can simply pipe the output from one function into the next function. These are known as pipelines and it demonstrates a clear order of what functions youre doing. 2 %&gt;% add(3) %&gt;% divide_by(5) %&gt;% add(1) %&gt;% multiply_by(3) ## [1] 6 It isnt necessary to move onto a new line for each function, the following works just as well: 2 %&gt;% add(3) %&gt;% divide_by(5) %&gt;% add(1) %&gt;% multiply_by(3) ## [1] 6 and while this is more concise, if you are doing many functions, this, again can look messy. Getting into the habit of creating a new line for each function will improve readability when youre coming back to look at your code in the future. Remember that when using the pipe, the following operations are equivalent f(a,b,c) a %&gt;% f(b,c) Functions from the tidyverse and a lot of other packages which follow the tidyverse style (or philosopy as described in the tidyverse vignette/manifesto) will generally take your data set as their first argument and will return another, updated data set. This allows you to make a really smooth chain of functions. 2.4 Tibbles In the previous lesson, we loaded up a dataset called iris. By default, data sets are loaded as a structure called a data.frame. The tidyverse team have built on this by creating a new structure nicknamed a tibble (officially theyre called tbl_df, short for table data frame), which works mostly the same, but it prints its data much neater and is a little more consistent in how we interact with it. Heres an example from the tidyverse starwars ## # A tibble: 87 x 14 ## name height mass hair_color skin_color eye_color birth_year sex gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Luke~ 172 77 blond fair blue 19 male mascu~ ## 2 C-3PO 167 75 &lt;NA&gt; gold yellow 112 none mascu~ ## 3 R2-D2 96 32 &lt;NA&gt; white, bl~ red 33 none mascu~ ## 4 Dart~ 202 136 none white yellow 41.9 male mascu~ ## 5 Leia~ 150 49 brown light brown 19 fema~ femin~ ## 6 Owen~ 178 120 brown, gr~ light blue 52 male mascu~ ## 7 Beru~ 165 75 brown light blue 47 fema~ femin~ ## 8 R5-D4 97 32 &lt;NA&gt; white, red red NA none mascu~ ## 9 Bigg~ 183 84 black light brown 24 male mascu~ ## 10 Obi-~ 182 77 auburn, w~ fair blue-gray 57 male mascu~ ## # ... with 77 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, ## # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; Notice how, when printing, we are only shown the first 10 rows and first few columns. It also gives us an indication of how many other rows there are and what other columns are present. If we were to print out a native data.frame from base R, we would have been shown everything and it would clog up our Console. If youre brave, then run as.data.frame(starwars) and it will convert this tibble into a dataframe and show just how messy it can be. The way that the data is organised above is the most common way of arranging our data. Each row is known as an observation and will usually be a single participant. Each column is a variable associated with that observation. Notice in the above, the third observation has a name variable of \"R2-D2\"and a mass variable of 32.0. Because each variable should be consistent, they are stored as vectors. As we recall, vectors must all be the same type. For every participant in this dataset, height is an integer indicated by the &lt;int&gt; under the variable name, meaning a whole number and eye_color is a character indicated by &lt;chr&gt;. We can also see the names of the variables in our dataset by using the names() function, or get the dimensions by using nrow(), ncol() or dim(): names(starwars) ## [1] &quot;name&quot; &quot;height&quot; &quot;mass&quot; &quot;hair_color&quot; &quot;skin_color&quot; ## [6] &quot;eye_color&quot; &quot;birth_year&quot; &quot;sex&quot; &quot;gender&quot; &quot;homeworld&quot; ## [11] &quot;species&quot; &quot;films&quot; &quot;vehicles&quot; &quot;starships&quot; nrow(starwars) ## [1] 87 ncol(starwars) ## [1] 14 dim(starwars) ## [1] 87 14 There are a few other advantages of tibbles over data.frames that are a lot more technical, so feel free to read about them yourself by loading the help file using ?tbl_df 2.5 One Table Verbs In the tidyverse functions that do things to your data are known as verbs. Which makes sense since verbs are doing words and we are doing something to our data. Today, were going to have a look at some of the verbs which act on a single dataset. There are a few that can act on two tables (allowing them to be combined into one table), but for now, well stick with one. 2.5.1 filter() The filter function allows us to pick out specific observations from our dataset depending on other values in our dataset. starwars %&gt;% filter(homeworld == &quot;Naboo&quot;) ## # A tibble: 11 x 14 ## name height mass hair_color skin_color eye_color birth_year sex gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 R2-D2 96 32 &lt;NA&gt; white, bl~ red 33 none mascu~ ## 2 Palp~ 170 75 grey pale yellow 82 male mascu~ ## 3 Jar ~ 196 66 none orange orange 52 male mascu~ ## 4 Roos~ 224 82 none grey orange NA male mascu~ ## 5 Rugo~ 206 NA none green orange NA male mascu~ ## 6 Ric ~ 183 NA brown fair blue NA &lt;NA&gt; &lt;NA&gt; ## 7 Quar~ 183 NA black dark brown 62 &lt;NA&gt; &lt;NA&gt; ## 8 Greg~ 185 85 black dark brown NA male mascu~ ## 9 Cordé 157 NA brown light brown NA fema~ femin~ ## 10 Dormé 165 NA brown light brown NA fema~ femin~ ## 11 Padm~ 165 45 brown light brown 46 fema~ femin~ ## # ... with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;, ## # vehicles &lt;list&gt;, starships &lt;list&gt; This has pulled out just the participants in the dataset that are from the planet \"Naboo\". Can you see how this has worked? It has created a logical vector, homeworld == \"Naboo\" from the data within the tibble. We could do this without using filter() by just using the functions available without the tidyverse stuff, but its messier: starwars[starwars$homeworld == &quot;Naboo&quot; &amp; !is.na(starwars$homeworld),] ## # A tibble: 11 x 14 ## name height mass hair_color skin_color eye_color birth_year sex gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 R2-D2 96 32 &lt;NA&gt; white, bl~ red 33 none mascu~ ## 2 Palp~ 170 75 grey pale yellow 82 male mascu~ ## 3 Jar ~ 196 66 none orange orange 52 male mascu~ ## 4 Roos~ 224 82 none grey orange NA male mascu~ ## 5 Rugo~ 206 NA none green orange NA male mascu~ ## 6 Ric ~ 183 NA brown fair blue NA &lt;NA&gt; &lt;NA&gt; ## 7 Quar~ 183 NA black dark brown 62 &lt;NA&gt; &lt;NA&gt; ## 8 Greg~ 185 85 black dark brown NA male mascu~ ## 9 Cordé 157 NA brown light brown NA fema~ femin~ ## 10 Dormé 165 NA brown light brown NA fema~ femin~ ## 11 Padm~ 165 45 brown light brown 46 fema~ femin~ ## # ... with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;, ## # vehicles &lt;list&gt;, starships &lt;list&gt; So firstly, we have to specify that homeworld is a variable in the starwars dataset, which we dont have to when using filter(). And perhaps more confusingly, we have to use this !is.na(starwars$homeworld) bit. The function, is.na() will check if values are missing, which are usually shown as NA and are slightly greyed out, e.g. R2-D2s hair colour is NA because they dont have any! filter() deals with this check and will ignore NA values, but the default R method does not and so we have to specify this. We can combine multiple criteria to hone in on which parts of our data we want to look at: starwars %&gt;% filter(species == &quot;Human&quot;, gender == &quot;feminine&quot;) ## # A tibble: 9 x 14 ## name height mass hair_color skin_color eye_color birth_year sex gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Leia~ 150 49 brown light brown 19 fema~ femin~ ## 2 Beru~ 165 75 brown light blue 47 fema~ femin~ ## 3 Mon ~ 150 NA auburn fair blue 48 fema~ femin~ ## 4 Shmi~ 163 NA black fair brown 72 fema~ femin~ ## 5 Cordé 157 NA brown light brown NA fema~ femin~ ## 6 Dormé 165 NA brown light brown NA fema~ femin~ ## 7 Joca~ 167 NA white fair blue NA fema~ femin~ ## 8 Rey NA NA brown light hazel NA fema~ femin~ ## 9 Padm~ 165 45 brown light brown 46 fema~ femin~ ## # ... with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;, ## # vehicles &lt;list&gt;, starships &lt;list&gt; This is the same as using the &amp; operator between each of these criteria, therefore, this returns all observations where all of the criteria are TRUE and we can use as many as we want. If we want to get observations where any of some criteria are true, we can use the | operator: starwars %&gt;% filter(homeworld == &quot;Naboo&quot; | species == &quot;Human&quot;) ## # A tibble: 41 x 14 ## name height mass hair_color skin_color eye_color birth_year sex gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Luke~ 172 77 blond fair blue 19 male mascu~ ## 2 R2-D2 96 32 &lt;NA&gt; white, bl~ red 33 none mascu~ ## 3 Dart~ 202 136 none white yellow 41.9 male mascu~ ## 4 Leia~ 150 49 brown light brown 19 fema~ femin~ ## 5 Owen~ 178 120 brown, gr~ light blue 52 male mascu~ ## 6 Beru~ 165 75 brown light blue 47 fema~ femin~ ## 7 Bigg~ 183 84 black light brown 24 male mascu~ ## 8 Obi-~ 182 77 auburn, w~ fair blue-gray 57 male mascu~ ## 9 Anak~ 188 84 blond fair blue 41.9 male mascu~ ## 10 Wilh~ 180 NA auburn, g~ fair blue 64 male mascu~ ## # ... with 31 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, ## # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; We can even use that is.na() function here to look for missing data, which can allow us to investigate holes in our data sets: starwars %&gt;% filter(is.na(birth_year)) ## # A tibble: 44 x 14 ## name height mass hair_color skin_color eye_color birth_year sex gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 R5-D4 97 32 &lt;NA&gt; white, red red NA none mascu~ ## 2 Jek ~ 180 110 brown fair blue NA male mascu~ ## 3 Arve~ NA NA brown fair brown NA male mascu~ ## 4 Nien~ 160 68 none grey black NA male mascu~ ## 5 Nute~ 191 90 none mottled g~ red NA male mascu~ ## 6 Roos~ 224 82 none grey orange NA male mascu~ ## 7 Rugo~ 206 NA none green orange NA male mascu~ ## 8 Ric ~ 183 NA brown fair blue NA &lt;NA&gt; &lt;NA&gt; ## 9 Watto 137 NA black blue, grey yellow NA male mascu~ ## 10 Sebu~ 112 40 none grey, red orange NA male mascu~ ## # ... with 34 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, ## # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; 2.5.2 slice() The slice function is a little bit cruder than the filter() function, in that it wants numbers to pull out certain observations. So we cant make it depend on criteria from our data, but it can be useful to preview certain subsections of it. starwars %&gt;% slice(51:60) ## # A tibble: 10 x 14 ## name height mass hair_color skin_color eye_color birth_year sex gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Eeth~ 171 NA black brown brown NA male mascu~ ## 2 Adi ~ 184 50 none dark blue NA fema~ femin~ ## 3 Saes~ 188 NA none pale orange NA male mascu~ ## 4 Yara~ 264 NA none white yellow NA male mascu~ ## 5 Plo ~ 188 80 none orange black 22 male mascu~ ## 6 Mas ~ 196 NA none blue blue NA male mascu~ ## 7 Greg~ 185 85 black dark brown NA male mascu~ ## 8 Cordé 157 NA brown light brown NA fema~ femin~ ## 9 Clie~ 183 NA brown fair blue 82 male mascu~ ## 10 Pogg~ 183 80 none green yellow NA male mascu~ ## # ... with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;, ## # vehicles &lt;list&gt;, starships &lt;list&gt; Similar to how we subsetted vectors and data.frames previously, we can also say which rows we dont want, so if I dont want the first 10 rows, I can use -(1:10) starwars %&gt;% slice(-(1:10)) ## # A tibble: 77 x 14 ## name height mass hair_color skin_color eye_color birth_year sex gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Anak~ 188 84 blond fair blue 41.9 male mascu~ ## 2 Wilh~ 180 NA auburn, g~ fair blue 64 male mascu~ ## 3 Chew~ 228 112 brown unknown blue 200 male mascu~ ## 4 Han ~ 180 80 brown fair brown 29 male mascu~ ## 5 Gree~ 173 74 &lt;NA&gt; green black 44 male mascu~ ## 6 Jabb~ 175 1358 &lt;NA&gt; green-tan~ orange 600 herm~ mascu~ ## 7 Wedg~ 170 77 brown fair hazel 21 male mascu~ ## 8 Jek ~ 180 110 brown fair blue NA male mascu~ ## 9 Yoda 66 17 white green brown 896 male mascu~ ## 10 Palp~ 170 75 grey pale yellow 82 male mascu~ ## # ... with 67 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, ## # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; It also has a few sibling functions which can come in handy for investigating our data. The first allows us to pull out a random set of observations: starwars %&gt;% slice_sample(n=10) ## # A tibble: 10 x 14 ## name height mass hair_color skin_color eye_color birth_year sex gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Palp~ 170 75 grey pale yellow 82 male mascu~ ## 2 Chew~ 228 112 brown unknown blue 200 male mascu~ ## 3 Bail~ 191 NA black tan brown 67 male mascu~ ## 4 Owen~ 178 120 brown, gr~ light blue 52 male mascu~ ## 5 Grie~ 216 159 none brown, wh~ green, y~ NA male mascu~ ## 6 Dart~ 202 136 none white yellow 41.9 male mascu~ ## 7 Rugo~ 206 NA none green orange NA male mascu~ ## 8 Luke~ 172 77 blond fair blue 19 male mascu~ ## 9 Jek ~ 180 110 brown fair blue NA male mascu~ ## 10 Nute~ 191 90 none mottled g~ red NA male mascu~ ## # ... with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;, ## # vehicles &lt;list&gt;, starships &lt;list&gt; There are also slice_min() or slice_max() which are used to pull out the rows with the highest or lowest values of a variable starwars %&gt;% slice_max(mass,n=3) ## # A tibble: 3 x 14 ## name height mass hair_color skin_color eye_color birth_year sex gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Jabb~ 175 1358 &lt;NA&gt; green-tan~ orange 600 herm~ mascu~ ## 2 Grie~ 216 159 none brown, wh~ green, y~ NA male mascu~ ## 3 IG-88 200 140 none metal red 15 none mascu~ ## # ... with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;, ## # vehicles &lt;list&gt;, starships &lt;list&gt; 2.5.3 arrange() Sometimes we may wish to re-arrange our data into a neater ordering. The arrange() function does just that. Itll sort your data by whatever variable(s) are passed to it: starwars %&gt;% arrange(name) ## # A tibble: 87 x 14 ## name height mass hair_color skin_color eye_color birth_year sex gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Ackb~ 180 83 none brown mot~ orange 41 male mascu~ ## 2 Adi ~ 184 50 none dark blue NA fema~ femin~ ## 3 Anak~ 188 84 blond fair blue 41.9 male mascu~ ## 4 Arve~ NA NA brown fair brown NA male mascu~ ## 5 Ayla~ 178 55 none blue hazel 48 fema~ femin~ ## 6 Bail~ 191 NA black tan brown 67 male mascu~ ## 7 Barr~ 166 50 black yellow blue 40 fema~ femin~ ## 8 BB8 NA NA none none black NA none mascu~ ## 9 Ben ~ 163 65 none grey, gre~ orange NA male mascu~ ## 10 Beru~ 165 75 brown light blue 47 fema~ femin~ ## # ... with 77 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, ## # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; And if we have ties, such as with mass, we can add a second sorting variable. starwars %&gt;% arrange(mass,height) ## # A tibble: 87 x 14 ## name height mass hair_color skin_color eye_color birth_year sex gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Ratt~ 79 15 none grey, blue unknown NA male mascu~ ## 2 Yoda 66 17 white green brown 896 male mascu~ ## 3 Wick~ 88 20 brown brown brown 8 male mascu~ ## 4 R2-D2 96 32 &lt;NA&gt; white, bl~ red 33 none mascu~ ## 5 R5-D4 97 32 &lt;NA&gt; white, red red NA none mascu~ ## 6 Sebu~ 112 40 none grey, red orange NA male mascu~ ## 7 Dud ~ 94 45 none blue, grey yellow NA male mascu~ ## 8 Padm~ 165 45 brown light brown 46 fema~ femin~ ## 9 Sly ~ 178 48 none pale white NA &lt;NA&gt; &lt;NA&gt; ## 10 Wat ~ 193 48 none green, gr~ unknown NA male mascu~ ## # ... with 77 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, ## # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; Notice this is sorted by mass first and then height. When using arrange(), NA values will always be put to the bottom of our tibble, which we can see by using the tail() function, which gives the bottom 6 rows of a tibble. Here the mass &amp; height are all NA. starwars %&gt;% arrange(mass,height) %&gt;% tail ## # A tibble: 6 x 14 ## name height mass hair_color skin_color eye_color birth_year sex gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Arve~ NA NA brown fair brown NA male mascu~ ## 2 Finn NA NA black dark dark NA male mascu~ ## 3 Rey NA NA brown light hazel NA fema~ femin~ ## 4 Poe ~ NA NA brown light brown NA male mascu~ ## 5 BB8 NA NA none none black NA none mascu~ ## 6 Capt~ NA NA unknown unknown unknown NA &lt;NA&gt; &lt;NA&gt; ## # ... with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;, ## # vehicles &lt;list&gt;, starships &lt;list&gt; By default, R will sort numeric data in ascending order and characters in alphabetical order. If we want to reverse this, we can use the desc() function: starwars %&gt;% arrange(desc(mass)) ## # A tibble: 87 x 14 ## name height mass hair_color skin_color eye_color birth_year sex gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Jabb~ 175 1358 &lt;NA&gt; green-tan~ orange 600 herm~ mascu~ ## 2 Grie~ 216 159 none brown, wh~ green, y~ NA male mascu~ ## 3 IG-88 200 140 none metal red 15 none mascu~ ## 4 Dart~ 202 136 none white yellow 41.9 male mascu~ ## 5 Tarf~ 234 136 brown brown blue NA male mascu~ ## 6 Owen~ 178 120 brown, gr~ light blue 52 male mascu~ ## 7 Bossk 190 113 none green red 53 male mascu~ ## 8 Chew~ 228 112 brown unknown blue 200 male mascu~ ## 9 Jek ~ 180 110 brown fair blue NA male mascu~ ## 10 Dext~ 198 102 none brown yellow NA male mascu~ ## # ... with 77 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, ## # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; Once again, the NA values are at the bottom. 2.5.4 select() The previous verbs all did something related to the rows in our data, whether that was extracting some subset of rows, or to organise the rows of our data better. select() acts similar to filter() but to extract columns or variables, rather than rows (observations) starwars %&gt;% select(name,height,mass) ## # A tibble: 87 x 3 ## name height mass ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Luke Skywalker 172 77 ## 2 C-3PO 167 75 ## 3 R2-D2 96 32 ## 4 Darth Vader 202 136 ## 5 Leia Organa 150 49 ## 6 Owen Lars 178 120 ## 7 Beru Whitesun lars 165 75 ## 8 R5-D4 97 32 ## 9 Biggs Darklighter 183 84 ## 10 Obi-Wan Kenobi 182 77 ## # ... with 77 more rows For this, we have selected only three variables. There are a few different ways we can use select(), depending on what we want to do. Again, we can say what we dont want: starwars %&gt;% select(-eye_color,-skin_color) ## # A tibble: 87 x 12 ## name height mass hair_color birth_year sex gender homeworld species films ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;lis&gt; ## 1 Luke~ 172 77 blond 19 male mascu~ Tatooine Human &lt;chr~ ## 2 C-3PO 167 75 &lt;NA&gt; 112 none mascu~ Tatooine Droid &lt;chr~ ## 3 R2-D2 96 32 &lt;NA&gt; 33 none mascu~ Naboo Droid &lt;chr~ ## 4 Dart~ 202 136 none 41.9 male mascu~ Tatooine Human &lt;chr~ ## 5 Leia~ 150 49 brown 19 fema~ femin~ Alderaan Human &lt;chr~ ## 6 Owen~ 178 120 brown, gr~ 52 male mascu~ Tatooine Human &lt;chr~ ## 7 Beru~ 165 75 brown 47 fema~ femin~ Tatooine Human &lt;chr~ ## 8 R5-D4 97 32 &lt;NA&gt; NA none mascu~ Tatooine Droid &lt;chr~ ## 9 Bigg~ 183 84 black 24 male mascu~ Tatooine Human &lt;chr~ ## 10 Obi-~ 182 77 auburn, w~ 57 male mascu~ Stewjon Human &lt;chr~ ## # ... with 77 more rows, and 2 more variables: vehicles &lt;list&gt;, ## # starships &lt;list&gt; We can use numbers, similar to slice() to get the nth columns starwars %&gt;% select(1,4,5,7:9) ## # A tibble: 87 x 6 ## name hair_color skin_color birth_year sex gender ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Luke Skywalker blond fair 19 male masculine ## 2 C-3PO &lt;NA&gt; gold 112 none masculine ## 3 R2-D2 &lt;NA&gt; white, blue 33 none masculine ## 4 Darth Vader none white 41.9 male masculine ## 5 Leia Organa brown light 19 female feminine ## 6 Owen Lars brown, grey light 52 male masculine ## 7 Beru Whitesun lars brown light 47 female feminine ## 8 R5-D4 &lt;NA&gt; white, red NA none masculine ## 9 Biggs Darklighter black light 24 male masculine ## 10 Obi-Wan Kenobi auburn, white fair 57 male masculine ## # ... with 77 more rows Personally, I dont tend to use the numeric version, as I prefer to use the names of the variables Im getting. Above, I used 7:9 to create a vector 7 8 9 and pull them. We can actully do this using the variable names (but this doesnt work outside of tidyverse) starwars %&gt;% select(name:eye_color) ## # A tibble: 87 x 6 ## name height mass hair_color skin_color eye_color ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Luke Skywalker 172 77 blond fair blue ## 2 C-3PO 167 75 &lt;NA&gt; gold yellow ## 3 R2-D2 96 32 &lt;NA&gt; white, blue red ## 4 Darth Vader 202 136 none white yellow ## 5 Leia Organa 150 49 brown light brown ## 6 Owen Lars 178 120 brown, grey light blue ## 7 Beru Whitesun lars 165 75 brown light blue ## 8 R5-D4 97 32 &lt;NA&gt; white, red red ## 9 Biggs Darklighter 183 84 black light brown ## 10 Obi-Wan Kenobi 182 77 auburn, white fair blue-gray ## # ... with 77 more rows One final thing we can use select() for is to rearrange our variables. The variables in select() will be in the order supplied: starwars %&gt;% select(height,mass,name) ## # A tibble: 87 x 3 ## height mass name ## &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 172 77 Luke Skywalker ## 2 167 75 C-3PO ## 3 96 32 R2-D2 ## 4 202 136 Darth Vader ## 5 150 49 Leia Organa ## 6 178 120 Owen Lars ## 7 165 75 Beru Whitesun lars ## 8 97 32 R5-D4 ## 9 183 84 Biggs Darklighter ## 10 182 77 Obi-Wan Kenobi ## # ... with 77 more rows But, what if we want to bring just one or two variables to the left (so we can see them easier) and not drop the rest? Well thats where a little tidy helper called everything() comes in: starwars %&gt;% select(homeworld,species,everything()) ## # A tibble: 87 x 14 ## homeworld species name height mass hair_color skin_color eye_color ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Tatooine Human Luke~ 172 77 blond fair blue ## 2 Tatooine Droid C-3PO 167 75 &lt;NA&gt; gold yellow ## 3 Naboo Droid R2-D2 96 32 &lt;NA&gt; white, bl~ red ## 4 Tatooine Human Dart~ 202 136 none white yellow ## 5 Alderaan Human Leia~ 150 49 brown light brown ## 6 Tatooine Human Owen~ 178 120 brown, gr~ light blue ## 7 Tatooine Human Beru~ 165 75 brown light blue ## 8 Tatooine Droid R5-D4 97 32 &lt;NA&gt; white, red red ## 9 Tatooine Human Bigg~ 183 84 black light brown ## 10 Stewjon Human Obi-~ 182 77 auburn, w~ fair blue-gray ## # ... with 77 more rows, and 6 more variables: birth_year &lt;dbl&gt;, sex &lt;chr&gt;, ## # gender &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; It basically acts as a filler for all the other variables that havent been mentioned in select() yet, and will retain the order of them as they appear in the dataset. Now that we know how to do something to our columns and our rows seperately, it makes sense to want to combine them. As discussed earlier, this is made very easy using the %&gt;% pipe. starwars %&gt;% filter(gender == &quot;feminine&quot;) %&gt;% select(name,height,mass,homeworld,species) ## # A tibble: 17 x 5 ## name height mass homeworld species ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Leia Organa 150 49 Alderaan Human ## 2 Beru Whitesun lars 165 75 Tatooine Human ## 3 Mon Mothma 150 NA Chandrila Human ## 4 Shmi Skywalker 163 NA Tatooine Human ## 5 Ayla Secura 178 55 Ryloth Twi&#39;lek ## 6 Adi Gallia 184 50 Coruscant Tholothian ## 7 Cordé 157 NA Naboo Human ## 8 Luminara Unduli 170 56.2 Mirial Mirialan ## 9 Barriss Offee 166 50 Mirial Mirialan ## 10 Dormé 165 NA Naboo Human ## 11 Zam Wesell 168 55 Zolan Clawdite ## 12 Taun We 213 NA Kamino Kaminoan ## 13 Jocasta Nu 167 NA Coruscant Human ## 14 R4-P17 96 NA &lt;NA&gt; Droid ## 15 Shaak Ti 178 57 Shili Togruta ## 16 Rey NA NA &lt;NA&gt; Human ## 17 Padmé Amidala 165 45 Naboo Human filter() outputs a tibble, which can then be passed to select() with ease. 2.5.5 mutate() The mutate function is really the powerhouse of the tidyverse and behind the %&gt;% pipe, you will probably use it a lot. It allows us to mutate or change our data as we need. This can be to change existing variables or to create new ones. First, we will convert height from cm to m by dividing by 100 starwars %&gt;% mutate(height = height/100) ## # A tibble: 87 x 14 ## name height mass hair_color skin_color eye_color birth_year sex gender ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Luke~ 1.72 77 blond fair blue 19 male mascu~ ## 2 C-3PO 1.67 75 &lt;NA&gt; gold yellow 112 none mascu~ ## 3 R2-D2 0.96 32 &lt;NA&gt; white, bl~ red 33 none mascu~ ## 4 Dart~ 2.02 136 none white yellow 41.9 male mascu~ ## 5 Leia~ 1.5 49 brown light brown 19 fema~ femin~ ## 6 Owen~ 1.78 120 brown, gr~ light blue 52 male mascu~ ## 7 Beru~ 1.65 75 brown light blue 47 fema~ femin~ ## 8 R5-D4 0.97 32 &lt;NA&gt; white, red red NA none mascu~ ## 9 Bigg~ 1.83 84 black light brown 24 male mascu~ ## 10 Obi-~ 1.82 77 auburn, w~ fair blue-gray 57 male mascu~ ## # ... with 77 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, ## # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; We can combine multiple mutations in a single mutate() function and R will perform them in order. This also means if we change a variable in one command, the updated version will be used from then on. Its also worth pointing out that new variables will by default be put at the end of our data, but we can use the .before or .after arguments to squeeze them in earlier (notice that there is a dot at the start of these agrgument names, its .before not before) starwars %&gt;% mutate(height = height/100, BMI = mass/height^2, .after = mass) ## # A tibble: 87 x 15 ## name height mass BMI hair_color skin_color eye_color birth_year sex ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Luke~ 1.72 77 26.0 blond fair blue 19 male ## 2 C-3PO 1.67 75 26.9 &lt;NA&gt; gold yellow 112 none ## 3 R2-D2 0.96 32 34.7 &lt;NA&gt; white, bl~ red 33 none ## 4 Dart~ 2.02 136 33.3 none white yellow 41.9 male ## 5 Leia~ 1.5 49 21.8 brown light brown 19 fema~ ## 6 Owen~ 1.78 120 37.9 brown, gr~ light blue 52 male ## 7 Beru~ 1.65 75 27.5 brown light blue 47 fema~ ## 8 R5-D4 0.97 32 34.0 &lt;NA&gt; white, red red NA none ## 9 Bigg~ 1.83 84 25.1 black light brown 24 male ## 10 Obi-~ 1.82 77 23.2 auburn, w~ fair blue-gray 57 male ## # ... with 77 more rows, and 6 more variables: gender &lt;chr&gt;, homeworld &lt;chr&gt;, ## # species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; Any fundamental changes that need to be made to your data, can be done using this mutate() function, and we will explore this much more in the future. 2.5.6 summarise() So now we can manipulate our data as a whole, but thats no good if we cant provide a summary of our data. As the name suggests, the summarise() function does exactly that. It performs functions on the variables as a whole and returns some sort of summary statistic (depending on what we ask for), and it returns that as another tibble starwars %&gt;% summarise(mass_avg = mean(mass, na.rm=T), mass_sd = sd(mass, na.rm=T)) ## # A tibble: 1 x 2 ## mass_avg mass_sd ## &lt;dbl&gt; &lt;dbl&gt; ## 1 97.3 169. Notice that for these two functions, mean() and sd(), I need to pass an extra argument, the na.rm=T just tells R to ignore the NA values. Otherwise, the default means that both of these functions would return NA (seems a bit silly, but it can be useful for spotting errors). 2.5.7 group_by() The final thing on todays agenda is the group_by() function which allows us to group our data in meaningful ways. This is exceptionally useful with the summarise() function above, as it can give us summary statistics based on other variables. Firstly, what does it look like to group our data? starwars %&gt;% group_by(gender) ## # A tibble: 87 x 14 ## # Groups: gender [3] ## name height mass hair_color skin_color eye_color birth_year sex gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Luke~ 172 77 blond fair blue 19 male mascu~ ## 2 C-3PO 167 75 &lt;NA&gt; gold yellow 112 none mascu~ ## 3 R2-D2 96 32 &lt;NA&gt; white, bl~ red 33 none mascu~ ## 4 Dart~ 202 136 none white yellow 41.9 male mascu~ ## 5 Leia~ 150 49 brown light brown 19 fema~ femin~ ## 6 Owen~ 178 120 brown, gr~ light blue 52 male mascu~ ## 7 Beru~ 165 75 brown light blue 47 fema~ femin~ ## 8 R5-D4 97 32 &lt;NA&gt; white, red red NA none mascu~ ## 9 Bigg~ 183 84 black light brown 24 male mascu~ ## 10 Obi-~ 182 77 auburn, w~ fair blue-gray 57 male mascu~ ## # ... with 77 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, ## # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt; The data looks mostly the same, except we now have a bit of information telling us that the data has been grouped and how many groups there are. But it gets more interesting when we perform a summarise(): starwars %&gt;% group_by(gender) %&gt;% summarise(number = n(), mass_avg = mean(mass, na.rm=T), mass_sd = sd(mass, na.rm=T), height_avg = mean(height, na.rm=T), height_sd = sd(height, na.rm=T), .groups=&quot;drop&quot;) ## # A tibble: 3 x 6 ## gender number mass_avg mass_sd height_avg height_sd ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 feminine 17 54.7 8.59 165. 23.6 ## 2 masculine 66 106. 185. 177. 37.6 ## 3 &lt;NA&gt; 4 48 NA 181. 2.89 This time we get a row of data for each of our groups. If we were to have more groups, wed have more rows. I used a few other new things here. The n() function will return the size of each group, and so can be useful here when summarising our data. I also passed an argument called .groups, which just stops R from telling me that it has ungrouped my data (this is a bit of a bug and hopefully will be removed in future versions). "],["enter-the-tidyverse-whats-next.html", "3 Enter The Tidyverse: Whats Next? 3.1 Refresher 3.2 Pivoting 3.3 Two Table Verbs 3.4 Decisions", " 3 Enter The Tidyverse: Whats Next? 3.1 Refresher Previously, we learned what a tibble is and how it stores data in observations/rows and variables/columns. We also learned about 7 fundamental data manipulation functions to allow us to edit these tibbles. filter() - selects observations based on a criteria/predicate slice() - selects obersevations based on number arrange() - re-arranges rows based on a variable select() - picks certain variables mutate() - changes variables or creates new ones summarise() - aggregates variables based on some functions group_by() - groups data sets by variables 3.2 Pivoting In general, datasets come in two forms, long or wide. Long data has many rows and fewer columns, and so it looks longer (vertically) if shown in a spreadsheet. Wide data has more columns and fewer rows (hence, it is wider). Data can be represented in both ways and each has advantages. This terminology might seem confusing for now, but were going to jump into an example dataset which includes how songs moved through the charts in the year 2000. Were given the date when the song entered the chart (which is always a Saturday) and then the ranking within the charts for the next 76 weeks. This data is in wide format. billboard ## # A tibble: 317 x 79 ## artist track date.entered wk1 wk2 wk3 wk4 wk5 wk6 wk7 wk8 ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2 Pac Baby~ 2000-02-26 87 82 72 77 87 94 99 NA ## 2 2Ge+h~ The ~ 2000-09-02 91 87 92 NA NA NA NA NA ## 3 3 Doo~ Kryp~ 2000-04-08 81 70 68 67 66 57 54 53 ## 4 3 Doo~ Loser 2000-10-21 76 76 72 69 67 65 55 59 ## 5 504 B~ Wobb~ 2000-04-15 57 34 25 17 17 31 36 49 ## 6 98^0 Give~ 2000-08-19 51 39 34 26 26 19 2 2 ## 7 A*Tee~ Danc~ 2000-07-08 97 97 96 95 100 NA NA NA ## 8 Aaliy~ I Do~ 2000-01-29 84 62 51 41 38 35 35 38 ## 9 Aaliy~ Try ~ 2000-03-18 59 53 38 28 21 18 16 14 ## 10 Adams~ Open~ 2000-08-26 76 76 74 69 68 67 61 58 ## # ... with 307 more rows, and 68 more variables: wk9 &lt;dbl&gt;, wk10 &lt;dbl&gt;, ## # wk11 &lt;dbl&gt;, wk12 &lt;dbl&gt;, wk13 &lt;dbl&gt;, wk14 &lt;dbl&gt;, wk15 &lt;dbl&gt;, wk16 &lt;dbl&gt;, ## # wk17 &lt;dbl&gt;, wk18 &lt;dbl&gt;, wk19 &lt;dbl&gt;, wk20 &lt;dbl&gt;, wk21 &lt;dbl&gt;, wk22 &lt;dbl&gt;, ## # wk23 &lt;dbl&gt;, wk24 &lt;dbl&gt;, wk25 &lt;dbl&gt;, wk26 &lt;dbl&gt;, wk27 &lt;dbl&gt;, wk28 &lt;dbl&gt;, ## # wk29 &lt;dbl&gt;, wk30 &lt;dbl&gt;, wk31 &lt;dbl&gt;, wk32 &lt;dbl&gt;, wk33 &lt;dbl&gt;, wk34 &lt;dbl&gt;, ## # wk35 &lt;dbl&gt;, wk36 &lt;dbl&gt;, wk37 &lt;dbl&gt;, wk38 &lt;dbl&gt;, wk39 &lt;dbl&gt;, wk40 &lt;dbl&gt;, ## # wk41 &lt;dbl&gt;, wk42 &lt;dbl&gt;, wk43 &lt;dbl&gt;, wk44 &lt;dbl&gt;, wk45 &lt;dbl&gt;, wk46 &lt;dbl&gt;, ## # wk47 &lt;dbl&gt;, wk48 &lt;dbl&gt;, wk49 &lt;dbl&gt;, wk50 &lt;dbl&gt;, wk51 &lt;dbl&gt;, wk52 &lt;dbl&gt;, ## # wk53 &lt;dbl&gt;, wk54 &lt;dbl&gt;, wk55 &lt;dbl&gt;, wk56 &lt;dbl&gt;, wk57 &lt;dbl&gt;, wk58 &lt;dbl&gt;, ## # wk59 &lt;dbl&gt;, wk60 &lt;dbl&gt;, wk61 &lt;dbl&gt;, wk62 &lt;dbl&gt;, wk63 &lt;dbl&gt;, wk64 &lt;dbl&gt;, ## # wk65 &lt;dbl&gt;, wk66 &lt;lgl&gt;, wk67 &lt;lgl&gt;, wk68 &lt;lgl&gt;, wk69 &lt;lgl&gt;, wk70 &lt;lgl&gt;, ## # wk71 &lt;lgl&gt;, wk72 &lt;lgl&gt;, wk73 &lt;lgl&gt;, wk74 &lt;lgl&gt;, wk75 &lt;lgl&gt;, wk76 &lt;lgl&gt; Each row represents one song, and therefore our observations are single songs and looking at when each song was in the charts. The position in the charts for each week from its date of release is represented by a separate variable. 3.2.1 pivot_longer() But, we might want an observation to represent each week for a track and so we can turn this data from wide to long format using the pivot_longer() function. The data currently has 317 rows and 76 weeks, so the resulting dataset should have 2.4092^{4} rows, since each track will now appear across 76 rows. billboard %&gt;% pivot_longer( cols = starts_with(&quot;wk&quot;), names_to = &quot;week_num&quot;, values_to = &quot;position&quot; ) ## # A tibble: 24,092 x 5 ## artist track date.entered week_num position ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk1 87 ## 2 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk2 82 ## 3 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk3 72 ## 4 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk4 77 ## 5 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk5 87 ## 6 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk6 94 ## 7 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk7 99 ## 8 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk8 NA ## 9 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk9 NA ## 10 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk10 NA ## # ... with 24,082 more rows So we used the pivot_longer() function with 4 arguments. Remember that the first argument is our dataset being piped in. Then weve given a name to the new variable that takes the previous variable names (names_to), similarly for the values we are extracting (values_to). The other argument is using a tidy helper called starts_with(). Remember the everything() helper from last time when we were using the select() function? This works similarly. Its saying that the columns we want to pivot are the ones that start with \"wk\". This dataset looks much bigger because it has more observations, but its still representing the same data. pivot_longer() has a few other tricks that we can do. For example, there are now lot of NA values in the position variable, these represent weeks when the track fell out of the top 100. We could use filter() to get rid of these, or we can tell pivot_longer() to do it for us. billboard %&gt;% pivot_longer( cols = starts_with(&quot;wk&quot;), names_to = &quot;week_num&quot;, values_to = &quot;position&quot;, values_drop_na = TRUE ) ## # A tibble: 5,307 x 5 ## artist track date.entered week_num position ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk1 87 ## 2 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk2 82 ## 3 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk3 72 ## 4 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk4 77 ## 5 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk5 87 ## 6 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk6 94 ## 7 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 wk7 99 ## 8 2Ge+her The Hardest Part Of ... 2000-09-02 wk1 91 ## 9 2Ge+her The Hardest Part Of ... 2000-09-02 wk2 87 ## 10 2Ge+her The Hardest Part Of ... 2000-09-02 wk3 92 ## # ... with 5,297 more rows Weve not got much less rows since weve gotten rid of the NA values from the position variable. The values_drop_na argument does exactly what the name suggests. Should we drop the NAs or keep them? If we want to work with this dataset though, wed prefer that week_num column to be a number, at the minute its character, which means we cant do any maths on it. pivot_longer() can get rid of the \"wk\" part of this and convert it to a number using two more arguments: billboard_long &lt;- billboard %&gt;% pivot_longer( cols = starts_with(&quot;wk&quot;), names_to = &quot;week_num&quot;, values_to = &quot;position&quot;, values_drop_na = TRUE, names_prefix = &quot;wk&quot;, names_transform = list(week_num = as.integer) ) billboard_long ## # A tibble: 5,307 x 5 ## artist track date.entered week_num position ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 1 87 ## 2 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 2 82 ## 3 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 3 72 ## 4 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 4 77 ## 5 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 5 87 ## 6 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 6 94 ## 7 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 7 99 ## 8 2Ge+her The Hardest Part Of ... 2000-09-02 1 91 ## 9 2Ge+her The Hardest Part Of ... 2000-09-02 2 87 ## 10 2Ge+her The Hardest Part Of ... 2000-09-02 3 92 ## # ... with 5,297 more rows The names_prefix argument told pivot_longer() to strip out the \"wk\" part of the week_num variable and then the names_transform applied the as.integer() function to these values. This one function just did quite a lot of work for us! Bear in mind that the arguments above can be given to the function in any order, as long as they are named. 3.2.2 pivot_wider() But what if we want to turn the data back? Or, in general, we want to convert a long dataset into a wide one? Well pivot_longer() has a twin called pivot_wider(). The arguments look very similar and so is their usage: billboard_long %&gt;% pivot_wider( names_from = &quot;week_num&quot;, names_prefix = &quot;wk&quot;, values_from = &quot;position&quot; ) ## # A tibble: 317 x 68 ## artist track date.entered wk1 wk2 wk3 wk4 wk5 wk6 wk7 wk8 ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2 Pac Baby~ 2000-02-26 87 82 72 77 87 94 99 NA ## 2 2Ge+h~ The ~ 2000-09-02 91 87 92 NA NA NA NA NA ## 3 3 Doo~ Kryp~ 2000-04-08 81 70 68 67 66 57 54 53 ## 4 3 Doo~ Loser 2000-10-21 76 76 72 69 67 65 55 59 ## 5 504 B~ Wobb~ 2000-04-15 57 34 25 17 17 31 36 49 ## 6 98^0 Give~ 2000-08-19 51 39 34 26 26 19 2 2 ## 7 A*Tee~ Danc~ 2000-07-08 97 97 96 95 100 NA NA NA ## 8 Aaliy~ I Do~ 2000-01-29 84 62 51 41 38 35 35 38 ## 9 Aaliy~ Try ~ 2000-03-18 59 53 38 28 21 18 16 14 ## 10 Adams~ Open~ 2000-08-26 76 76 74 69 68 67 61 58 ## # ... with 307 more rows, and 57 more variables: wk9 &lt;dbl&gt;, wk10 &lt;dbl&gt;, ## # wk11 &lt;dbl&gt;, wk12 &lt;dbl&gt;, wk13 &lt;dbl&gt;, wk14 &lt;dbl&gt;, wk15 &lt;dbl&gt;, wk16 &lt;dbl&gt;, ## # wk17 &lt;dbl&gt;, wk18 &lt;dbl&gt;, wk19 &lt;dbl&gt;, wk20 &lt;dbl&gt;, wk21 &lt;dbl&gt;, wk22 &lt;dbl&gt;, ## # wk23 &lt;dbl&gt;, wk24 &lt;dbl&gt;, wk25 &lt;dbl&gt;, wk26 &lt;dbl&gt;, wk27 &lt;dbl&gt;, wk28 &lt;dbl&gt;, ## # wk29 &lt;dbl&gt;, wk30 &lt;dbl&gt;, wk31 &lt;dbl&gt;, wk32 &lt;dbl&gt;, wk33 &lt;dbl&gt;, wk34 &lt;dbl&gt;, ## # wk35 &lt;dbl&gt;, wk36 &lt;dbl&gt;, wk37 &lt;dbl&gt;, wk38 &lt;dbl&gt;, wk39 &lt;dbl&gt;, wk40 &lt;dbl&gt;, ## # wk41 &lt;dbl&gt;, wk42 &lt;dbl&gt;, wk43 &lt;dbl&gt;, wk44 &lt;dbl&gt;, wk45 &lt;dbl&gt;, wk46 &lt;dbl&gt;, ## # wk47 &lt;dbl&gt;, wk48 &lt;dbl&gt;, wk49 &lt;dbl&gt;, wk50 &lt;dbl&gt;, wk51 &lt;dbl&gt;, wk52 &lt;dbl&gt;, ## # wk53 &lt;dbl&gt;, wk54 &lt;dbl&gt;, wk55 &lt;dbl&gt;, wk56 &lt;dbl&gt;, wk57 &lt;dbl&gt;, wk58 &lt;dbl&gt;, ## # wk59 &lt;dbl&gt;, wk60 &lt;dbl&gt;, wk61 &lt;dbl&gt;, wk62 &lt;dbl&gt;, wk63 &lt;dbl&gt;, wk64 &lt;dbl&gt;, ## # wk65 &lt;dbl&gt; Pretty simple to do this and it gets the data back to how it was previously. Oftentimes it can be quite useful to pivot data around and then return back to its original form. A reason we might want to do this is to edit all of the week data all at once. In the billboard dataset, the position in the charts is based on number of weeks since the track was released. So 2 Pacs Baby Dont Cry in the first row, was released a few months before 3 Doors Downs Kryptonite, but a week after each of their releases they were in chart position 87 and 91 respectively. What if we wanted to know where they were for the actual weeks of the year? First were going to load up another package called lubridate which makes working with dates a lot smoother. ## ## Attaching package: &#39;lubridate&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## date, intersect, setdiff, union And then we can figure out how far into the year each song was released (note that the date.entered is a Saturday and the year 2000 started on a Saturday). To do this, well subtract the 1st January from the date.entered to get the number of days between them and then divide it by 7 to get the number of weeks. By adding the week_num - 1, we can see which week each position is from, and we can overwrite the week_num value with this new value. billboard_long %&gt;% mutate(week_num = as.integer((date.entered - dmy(&quot;01/01/2000&quot;))/7) + week_num - 1) ## # A tibble: 5,307 x 5 ## artist track date.entered week_num position ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 8 87 ## 2 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 9 82 ## 3 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 10 72 ## 4 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 11 77 ## 5 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 12 87 ## 6 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 13 94 ## 7 2 Pac Baby Don&#39;t Cry (Keep... 2000-02-26 14 99 ## 8 2Ge+her The Hardest Part Of ... 2000-09-02 35 91 ## 9 2Ge+her The Hardest Part Of ... 2000-09-02 36 87 ## 10 2Ge+her The Hardest Part Of ... 2000-09-02 37 92 ## # ... with 5,297 more rows Next we can filter() out the weeks from outside of the year 2000 by getting rid of week_num that are less than 0 or greater than 52, and then by sorting the data by this week_num, well get the columns in the right order when we come to pivot_wider() back around. billboard_long %&gt;% mutate(week_num = as.integer((date.entered - dmy(&quot;01/01/2000&quot;))/7) + week_num - 1) %&gt;% filter(between(week_num,0,52)) %&gt;% arrange(week_num) %&gt;% pivot_wider( names_from = week_num, names_prefix = &quot;wk&quot;, values_from = position ) ## # A tibble: 317 x 56 ## artist track date.entered wk0 wk1 wk2 wk3 wk4 wk5 wk6 wk7 ## &lt;chr&gt; &lt;chr&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Aguil~ What~ 1999-11-27 13 11 1 1 2 2 3 3 ## 2 Amber Sexu~ 1999-07-17 69 59 58 58 49 44 42 46 ## 3 Backs~ Show~ 2000-01-01 74 62 55 25 16 14 12 10 ## 4 Blaque Brin~ 1999-10-23 9 9 10 5 5 6 8 9 ## 5 Blige~ Deep~ 1999-11-13 64 65 67 63 67 75 85 94 ## 6 Blink~ All ~ 1999-12-04 59 51 50 35 26 15 7 6 ## 7 Brock~ A Co~ 2000-01-01 93 75 92 NA NA NA NA NA ## 8 Carey~ Than~ 1999-12-11 50 41 37 26 22 22 2 1 ## 9 Count~ Hang~ 1999-11-06 35 32 29 29 28 32 38 48 ## 10 Creed High~ 1999-09-11 61 57 60 61 NA NA NA NA ## # ... with 307 more rows, and 45 more variables: wk8 &lt;dbl&gt;, wk9 &lt;dbl&gt;, ## # wk10 &lt;dbl&gt;, wk11 &lt;dbl&gt;, wk12 &lt;dbl&gt;, wk13 &lt;dbl&gt;, wk14 &lt;dbl&gt;, wk15 &lt;dbl&gt;, ## # wk16 &lt;dbl&gt;, wk17 &lt;dbl&gt;, wk18 &lt;dbl&gt;, wk19 &lt;dbl&gt;, wk20 &lt;dbl&gt;, wk21 &lt;dbl&gt;, ## # wk22 &lt;dbl&gt;, wk23 &lt;dbl&gt;, wk24 &lt;dbl&gt;, wk25 &lt;dbl&gt;, wk26 &lt;dbl&gt;, wk27 &lt;dbl&gt;, ## # wk28 &lt;dbl&gt;, wk29 &lt;dbl&gt;, wk30 &lt;dbl&gt;, wk31 &lt;dbl&gt;, wk32 &lt;dbl&gt;, wk33 &lt;dbl&gt;, ## # wk34 &lt;dbl&gt;, wk35 &lt;dbl&gt;, wk36 &lt;dbl&gt;, wk37 &lt;dbl&gt;, wk38 &lt;dbl&gt;, wk39 &lt;dbl&gt;, ## # wk40 &lt;dbl&gt;, wk41 &lt;dbl&gt;, wk42 &lt;dbl&gt;, wk43 &lt;dbl&gt;, wk44 &lt;dbl&gt;, wk45 &lt;dbl&gt;, ## # wk46 &lt;dbl&gt;, wk47 &lt;dbl&gt;, wk48 &lt;dbl&gt;, wk49 &lt;dbl&gt;, wk50 &lt;dbl&gt;, wk51 &lt;dbl&gt;, ## # wk52 &lt;dbl&gt; 3.3 Two Table Verbs In the previous lesson we looked at the verbs associated with a single table. However, a lot of the time, our data doesnt come in a nice and neat single spreadsheet so we might have to combine multiple datasets into a single tibble. There are various ways to do this kind of combining depending on what the data looks like and our intentions with it. 3.3.1 bind_rows() If we have two tables that are (more or less) the same, we can just stick them together with one on top of the other. data1 &lt;- tibble(x=1:3,y=c(&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;)) data2 &lt;- tibble(x=4:6,y=c(&quot;orange&quot;,&quot;purple&quot;,&quot;yellow&quot;)) data1 ## # A tibble: 3 x 2 ## x y ## &lt;int&gt; &lt;chr&gt; ## 1 1 red ## 2 2 green ## 3 3 blue data2 ## # A tibble: 3 x 2 ## x y ## &lt;int&gt; &lt;chr&gt; ## 1 4 orange ## 2 5 purple ## 3 6 yellow To do this, we just pass both tables to the bind_rows() function which will essentially stack them on top of eachother bind_rows(data1,data2) ## # A tibble: 6 x 2 ## x y ## &lt;int&gt; &lt;chr&gt; ## 1 1 red ## 2 2 green ## 3 3 blue ## 4 4 orange ## 5 5 purple ## 6 6 yellow This function can take in as many tables as we want (for now, well just put in two). If we want to bind more together, just pass them as extra arguments bind_rows( data1, data2, tibble(x=7,y=&quot;black&quot;), tibble(x=8,y=&quot;white&quot;), ) ## # A tibble: 8 x 2 ## x y ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 red ## 2 2 green ## 3 3 blue ## 4 4 orange ## 5 5 purple ## 6 6 yellow ## 7 7 black ## 8 8 white This is a very simple procedure, however we can add a bit of complexity if we want to keep track of where our data is coming from. For example, you might record a lot of data and so have a spreadsheet for each participant. We can add a new column that will identify each tibble we are binding bind_rows( set1 = data1, set2 = data2, .id = &quot;set&quot; ) ## # A tibble: 6 x 3 ## set x y ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 set1 1 red ## 2 set1 2 green ## 3 set1 3 blue ## 4 set2 4 orange ## 5 set2 5 purple ## 6 set2 6 yellow bind_rows() even works if your data isnt the exact same, itll just put NA where there was missing data: bind_rows( data1, tibble(x=8) ) ## # A tibble: 4 x 2 ## x y ## &lt;dbl&gt; &lt;chr&gt; ## 1 1 red ## 2 2 green ## 3 3 blue ## 4 8 &lt;NA&gt; 3.3.2 bind_cols() Just like with select() and filter() which work on columns &amp; rows respectively, bind_rows() has a twin called bind_cols() and this will stick the tables together next to one another. data3 &lt;- tibble(z=c(&quot;cat&quot;,&quot;dog&quot;,&quot;mouse&quot;),w=100:102) bind_cols(data1,data3) ## # A tibble: 3 x 4 ## x y z w ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 1 red cat 100 ## 2 2 green dog 101 ## 3 3 blue mouse 102 3.3.3 joins The above two methods of combining data dont do an awful lot. They just stick the data together without changing much. However, we might want to match our data together based on a common identifier. For this, were going to use some data on flights leaving New York City, which is stored in a package called nycflights library(nycflights13) flights2 &lt;- select(flights,year,month,day,hour,origin,dest,tailnum,carrier) flights2 ## # A tibble: 336,776 x 8 ## year month day hour origin dest tailnum carrier ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2013 1 1 5 EWR IAH N14228 UA ## 2 2013 1 1 5 LGA IAH N24211 UA ## 3 2013 1 1 5 JFK MIA N619AA AA ## 4 2013 1 1 5 JFK BQN N804JB B6 ## 5 2013 1 1 6 LGA ATL N668DN DL ## 6 2013 1 1 5 EWR ORD N39463 UA ## 7 2013 1 1 6 EWR FLL N516JB B6 ## 8 2013 1 1 6 LGA IAD N829AS EV ## 9 2013 1 1 6 JFK MCO N593JB B6 ## 10 2013 1 1 6 LGA ORD N3ALAA AA ## # ... with 336,766 more rows As well as the actual flight information, this package also contains data about the airlines, which we can see here airlines ## # A tibble: 16 x 2 ## carrier name ## &lt;chr&gt; &lt;chr&gt; ## 1 9E Endeavor Air Inc. ## 2 AA American Airlines Inc. ## 3 AS Alaska Airlines Inc. ## 4 B6 JetBlue Airways ## 5 DL Delta Air Lines Inc. ## 6 EV ExpressJet Airlines Inc. ## 7 F9 Frontier Airlines Inc. ## 8 FL AirTran Airways Corporation ## 9 HA Hawaiian Airlines Inc. ## 10 MQ Envoy Air ## 11 OO SkyWest Airlines Inc. ## 12 UA United Air Lines Inc. ## 13 US US Airways Inc. ## 14 VX Virgin America ## 15 WN Southwest Airlines Co. ## 16 YV Mesa Airlines Inc. How would we go about sticking these together. We cant just bind_cols() since we want to match them based on the value in carrier. To do this, we can use left_join(): flights2 %&gt;% left_join(airlines, by=&quot;carrier&quot;) ## # A tibble: 336,776 x 9 ## year month day hour origin dest tailnum carrier name ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2013 1 1 5 EWR IAH N14228 UA United Air Lines Inc. ## 2 2013 1 1 5 LGA IAH N24211 UA United Air Lines Inc. ## 3 2013 1 1 5 JFK MIA N619AA AA American Airlines Inc. ## 4 2013 1 1 5 JFK BQN N804JB B6 JetBlue Airways ## 5 2013 1 1 6 LGA ATL N668DN DL Delta Air Lines Inc. ## 6 2013 1 1 5 EWR ORD N39463 UA United Air Lines Inc. ## 7 2013 1 1 6 EWR FLL N516JB B6 JetBlue Airways ## 8 2013 1 1 6 LGA IAD N829AS EV ExpressJet Airlines Inc. ## 9 2013 1 1 6 JFK MCO N593JB B6 JetBlue Airways ## 10 2013 1 1 6 LGA ORD N3ALAA AA American Airlines Inc. ## # ... with 336,766 more rows As well as supplying the two datasets, weve also told R which variable we want to match on. By default, R will just look at which variables appear in both datasets and match on those. And yes, you can match on multiple variables, like so. flights2 %&gt;% left_join( select(weather,origin,year,month,day,hour,temp) ) ## Joining, by = c(&quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;hour&quot;, &quot;origin&quot;) ## # A tibble: 336,776 x 9 ## year month day hour origin dest tailnum carrier temp ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2013 1 1 5 EWR IAH N14228 UA 39.0 ## 2 2013 1 1 5 LGA IAH N24211 UA 39.9 ## 3 2013 1 1 5 JFK MIA N619AA AA 39.0 ## 4 2013 1 1 5 JFK BQN N804JB B6 39.0 ## 5 2013 1 1 6 LGA ATL N668DN DL 39.9 ## 6 2013 1 1 5 EWR ORD N39463 UA 39.0 ## 7 2013 1 1 6 EWR FLL N516JB B6 37.9 ## 8 2013 1 1 6 LGA IAD N829AS EV 39.9 ## 9 2013 1 1 6 JFK MCO N593JB B6 37.9 ## 10 2013 1 1 6 LGA ORD N3ALAA AA 39.9 ## # ... with 336,766 more rows Above we used the left_join() function, but there are actually four main types of *_join() functions in R. They each match the data in slightly different ways. 3.3.3.1 full_join() full_join() will match every instance in your two datasets. data1 &lt;- tibble(id = 1:4,x=runif(4)) data2 &lt;- tibble(id = 2:7,y=runif(6)) full_join(data1,data2,by=&quot;id&quot;) ## # A tibble: 7 x 3 ## id x y ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 0.565 NA ## 2 2 0.140 0.229 ## 3 3 0.254 0.152 ## 4 4 0.154 0.669 ## 5 5 NA 0.0199 ## 6 6 NA 0.756 ## 7 7 NA 0.740 The value of id = 5 isnt present in data1 and so there isnt a row associated with that in the data and so R just puts an NA in those. Similarly for the other NA values, theyre not present in both datasets. full_join() will return every row from both data sets being joined together. 3.3.3.2 inner_join() inner_join(data1,data2,by=&quot;id&quot;) ## # A tibble: 3 x 3 ## id x y ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2 0.140 0.229 ## 2 3 0.254 0.152 ## 3 4 0.154 0.669 The inner_join() function returns only the rows that are in both datasets. It doesnt give us any NA, and returns a relatively small dataset. 3.3.3.3 left_join() &amp; right_join() The left_join() and right_join() functions will keep everything from either the first or the second dataset being supplied. left_join(data1,data2,by=&quot;id&quot;) ## # A tibble: 4 x 3 ## id x y ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 0.565 NA ## 2 2 0.140 0.229 ## 3 3 0.254 0.152 ## 4 4 0.154 0.669 Here, we dont keep the rows from y that are not in x (i.e. id = 5,6,7). right_join(data1,data2,by=&quot;id&quot;) ## # A tibble: 6 x 3 ## id x y ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2 0.140 0.229 ## 2 3 0.254 0.152 ## 3 4 0.154 0.669 ## 4 5 NA 0.0199 ## 5 6 NA 0.756 ## 6 7 NA 0.740 This time we have everything from y, but not all of the results for x because there isnt a row for id=1 in the data2 dataset. 3.4 Decisions Not all tasks in R require us to do maths or logical. Sometimes, we might have to make a choice of what to return based on an input. Here well have a look at some of the options available if we need to make decisions like this 3.4.1 if_else() The if_else() function takes in three arguments, which should all be either vectors of the same length, or length 1. The first argument is then analysed and it should return a logical vector (TRUEs and FALSEs). Wherever this logical vector is TRUE, it will return the appropriate value from the second argument, and wherever it is FALSE, it will return the appropriate value from the third argument. Lets see it in action: logical_vector &lt;- c(T,T,F,F,T) true_response &lt;- letters[1:5] false_response &lt;- letters[22:26] if_else( logical_vector, true_response, false_response ) ## [1] &quot;a&quot; &quot;b&quot; &quot;x&quot; &quot;y&quot; &quot;e&quot; So, since our logical vector has TRUE for the first two values, the first two values from the true_response are given here, followed by two from the false_response and then finally the true_response. This is a very quick way to make a vectorised choice in R. And dont forget, this function can be used in a mutate() function to edit our datasets flights2 %&gt;% mutate(am_pm = if_else(hour &lt; 12, &quot;am&quot;,&quot;pm&quot;)) %&gt;% slice_sample(n=10) ## # A tibble: 10 x 9 ## year month day hour origin dest tailnum carrier am_pm ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2013 10 18 16 LGA MSP N944DL DL pm ## 2 2013 9 16 15 LGA ORF N724EV EV pm ## 3 2013 12 30 15 LGA MIA N3AYAA AA pm ## 4 2013 8 27 21 LGA DTW N1EAMQ MQ pm ## 5 2013 2 26 9 JFK BUF N599JB B6 am ## 6 2013 8 6 6 EWR IND N11199 EV am ## 7 2013 11 14 10 LGA CLT N713UW US am ## 8 2013 10 27 12 EWR DAY N13913 EV pm ## 9 2013 4 21 18 LGA XNA N717MQ MQ pm ## 10 2013 6 16 13 EWR STL N12563 EV pm 3.4.2 recode() The if_else() function is useful for making a decision between two options, but that situation doesnt arise very often. Sometimes, we might need to replace a certain value and so the recode() function is useful for that flights2 %&gt;% mutate(month_string = recode(month, `1`=&quot;January&quot;, `2`=&quot;February&quot;, `3`=&quot;March&quot;, `4`=&quot;April&quot;, `5`=&quot;May&quot;, `6`=&quot;June&quot;, `7`=&quot;July&quot;, `8`=&quot;August&quot;, `9`=&quot;September&quot;, `10`=&quot;October&quot;, `11`=&quot;November&quot;, `12`=&quot;December&quot;, )) %&gt;% slice_sample(n=10) ## # A tibble: 10 x 9 ## year month day hour origin dest tailnum carrier month_string ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2013 2 7 16 JFK CLT N249JB B6 February ## 2 2013 6 17 15 LGA DFW N3JRAA AA June ## 3 2013 12 25 10 LGA CLT N770UW US December ## 4 2013 5 29 16 EWR SFO N38467 UA May ## 5 2013 2 20 8 LGA DEN N562UA UA February ## 6 2013 12 12 16 EWR RDU N13978 EV December ## 7 2013 4 15 5 LGA IAH N578UA UA April ## 8 2013 7 2 18 EWR SFO N509UA UA July ## 9 2013 4 21 6 LGA MKE N410WN WN April ## 10 2013 6 25 18 JFK PBI N559JB B6 June 3.4.3 case_when() However, the recode() function isnt too flexible, itll only look at a single variable and then decide what to do based on that value. We might want to check something more complicated, and so for things like that we can use the case_when() function, which has a unique syntax. flights2 %&gt;% mutate(season = case_when( month &lt; 2 | month == 12 ~ &quot;Winter&quot;, month &lt; 5 ~ &quot;Spring&quot;, month &lt; 8 ~ &quot;Summer&quot;, T ~ &quot;Autumn&quot; )) ## # A tibble: 336,776 x 9 ## year month day hour origin dest tailnum carrier season ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2013 1 1 5 EWR IAH N14228 UA Winter ## 2 2013 1 1 5 LGA IAH N24211 UA Winter ## 3 2013 1 1 5 JFK MIA N619AA AA Winter ## 4 2013 1 1 5 JFK BQN N804JB B6 Winter ## 5 2013 1 1 6 LGA ATL N668DN DL Winter ## 6 2013 1 1 5 EWR ORD N39463 UA Winter ## 7 2013 1 1 6 EWR FLL N516JB B6 Winter ## 8 2013 1 1 6 LGA IAD N829AS EV Winter ## 9 2013 1 1 6 JFK MCO N593JB B6 Winter ## 10 2013 1 1 6 LGA ORD N3ALAA AA Winter ## # ... with 336,766 more rows "],["show-your-work.html", "4 Show Your Work", " 4 Show Your Work Coming Soon "],["final-coding.html", "5 Final Coding", " 5 Final Coding Coming Soon "]]
