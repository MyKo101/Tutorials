[
["index.html", "Introduction to Statistics Using R Welcome", " Introduction to Statistics Using R Michael A Barrowman m.a.barrowman@ljmu.ac.uk 2020-06-09 Welcome Welcome to the Lecture Notes for LJMU’s R Tutorial. Please use the contents list on the left to browse through the notes. You can expand or minimise the contents by clicking the three bars () in the top left. "],
["introduction-to-r.html", "1 Introduction to R 1.1 R &amp; RStudio 1.2 Help 1.3 Vectorisation 1.4 Statistics 1.5 Probabilities", " 1 Introduction to R 1.1 R &amp; RStudio 1.1.1 R R is a programming language that is designed to work quickly and efficiently with large amounts of data, this is done through the unique way it processes this data. It is open source, meaning that other people from around the world can easily contribute code that you can use through add-ons, known as packages. Another reason for R’s popularity is that it (and the applications that run it) are free and (perhaps because it is free) the support online (from other ordinary users) is incredibly helpful. 1.1.2 RStudio If you try to download R directly, you will also download a program called RGui. This is the default program for running R code. For what it does, RGui is fine. But we don’t want fine, we want GREAT! So we’re going to use another program called RStudio. RStudio organises your workspace a little bit better than the default RGui and allows for better interacticve help features which we’ll discuss later. Below is an example of what RStudio should look like. The screenshow shows the four panes that we usually work with. Top-Left shows the Script, which is the code file we’re currently working in. Code written here won’t be run immediately, but it allows us to save code to be re-run later. Bottom-Left shows the Console, code written here will be run, so be careful what you type here. Top-Right is the Workspace, which shows the variables/data that RStudio is storing for us and that we can use. Bottom-Right shows the Viewer, which primarily displays Plots and Help. Of course there is a lot more going on here, but for the most part, these are the important bits. Remember: R is the language and RStudio is the application, but you can’t use RStudio without R! (That said, I’m probably going to use the two interchangeably throughout) 1.1.3 Where to get them? When you’re using an LJMU computer, you can search for “RStudio” in the LJMU Application Player to download it. This course is designed for use with RStudio 64 (with the circular logo). Elsewhere, you can download it from their webpage. As mentioned above, RStudio is free and will automatically install R as well. 1.1.4 First steps When you first open RStudio, what you see won’t be like the screenshot. That’s because there is no Script open and so the Console fills the entire left side. It’s also filled with some information regarding licencing and the version of R you are currently running. The first step in RStudio is to create a new script. Go to File &gt; New File &gt; R Script (or press Ctrl + Shift + N on Windows or Cmd + Shift N on Mac). The Script pane should now appear with a tab called “Untitled 1”. In the Console pane, type 2+2 and hit Enter. 2+2 ## [1] 4 RStudio just ran the code immediately. The [1] here just means that the 4 is the first result from what R has calculated (we’ll get on to that in a bit). Next, with the Console still selected, press up and RStudio will recall the previously run line of code. and you can change the code and you run it again 2+3 ## [1] 5 This time, in the Script pane, type pi+1, hightlight it and press Ctrl + Enter (or Cmd + Enter on Mac). pi+1 ## [1] 4.141593 This will automatically transfer the code into the Console and run it. Importantly, however the code is still in the Script pane, ready to be edited and/or used again. Congratulations! You just did some coding! 1.2 Help 1.2.1 Help Files For any problem you might have, your first port of call in RStudio is the ? symbol. R mostly works with functions (which we will get to prety soon), and so if you need help in RStudio, you can type a question mark followed by the name of that function and help will pop up in the Viewer pane ?mean 1.2.2 Search Next port of call should be Google/Ecosia/Bing or whatever your Search Engine of choice is. If you have a question that you need to know, type in “R” and then just ask that question to your search engine. I don’t mean try to phrase it in a certain way, I mean write the question exactly how you would ask it! When you search for something, a lot of results will probably be tutorials on how to do what you’re trying to do. If what you’re asking is a common question, these will be good resources. For more unusual questions, Stack Exchange is the most reliable forum for R answers. It is full of users who are more than willing to answer your difficult questions (some of them even enjoy it!) 1.2.3 Ask Surprisingly enough, Statisticians love Twitter. If you have a question, just post it with the #RStats hashtag and you’ll probably get some reasonable responses. Or tweet it with #LJMU_MSIT and I will either reply or retweet it to more stats people. Finally, the Maths, Stats &amp; IT Team run regular Drop-In Sessions and One-To-Ones which you’re more than welcome to come by to. Just check out the Library Calendar to find a suitable session. Remember, never feel like you’re asking a stupid question. If you don’t know the answer, just ask! 1.3 Vectorisation 1.3.1 Vectors In mathematics, a vector is usually a set of ordered numbers which can be used to represent a point in 2/3D space. However, R uses vectors in a slightly different manner to essentially mean a list of data (although a list is a different thing in R). I can create a vector in R by using the c function and passing some numbers as arguments, separated by a comma. c(1,2,3) ## [1] 1 2 3 I used a little bit of Jargon there, but to keep things clear. A function is a command that tells R to do something and an argument is the information or data you give to the function so it can do it’s job. Sometimes functions don’t need arguments: Sys.time() ## [1] &quot;2020-06-09 20:11:02 BST&quot; But the key to remember is that a function has brackets () right after it’s name. And, a word of warning, R is Case Sensitive. This means you need to be careful that you use upper and lower case appropriately. sys.time() ## Error in sys.time(): could not find function &quot;sys.time&quot; We’ve now created a vector of numbers but we’ve not done anything with these numbers. What is happening here: c(1,2,3) + 10 ## [1] 11 12 13 In the jargon of R (and computer programming in general), the addition symbol (+) here is called an operator. Operators take something on the left and something on the right and do something with them. Here are several more and you should recognise most of them: + - * / &lt; &gt; ^ == != : In order: Addition (+), Subtraction (-), Multiplication (*), Division (/), Less Than (&lt;), Greater Than (&gt;), Exponentiation (^), Equivalency (==) (i.e. are these two things the same?) and Non-Equivalency (!=) (are these two things different?). The last one, is probably new to you. the : operator works with numbers to create a vector that runs from the first number to the second and is very useful for quickly creating big vectors. 1:100 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ## [19] 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 ## [37] 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 ## [55] 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 ## [73] 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 ## [91] 91 92 93 94 95 96 97 98 99 100 This also demonstrates what the [1] meant earlier. The element next to it is the first element. The next row here, shows [19], which means that 19 is the nineteenth element, and so on. This makes it easier, if you’re dealing with large data, to pinpoint where something might be wrong. Try running the code 1:1000 (either in the Console or the Script pane). What do you think is happening here? length(1:1000) ## [1] 1000 what happens if you run the code length(1:(10^6))? And what about length(1:(10^15)). Try length(1:(10^16)) ## Error in 1:(10^16): result would be too long a vector R doesn’t even try it. R knows its limits But it can make it up to 1015, which means that R created a vector that was 1015 elements long before figuring out its length. And it did it really quickly (because R is good with vectors) 1.3.2 Data Types We’ve just learned about Vectors as lists(even though list means something else) of numbers. But Vectors can also be character vectors. Sometimes called strings, character vectors just means words: c(&quot;Hello&quot;,&quot;World&quot;) ## [1] &quot;Hello&quot; &quot;World&quot; Another basic data type in R is the logical, which represents TRUE or FALSE values. c(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;,&quot;yellow&quot;) == &quot;red&quot; ## [1] TRUE FALSE FALSE FALSE Here, we created a vector of characters and then checked whether each of them (one-by-one) were equal to the character vector \"red\". Again, however, remember that R is Case Senstive: &quot;red&quot; == &quot;Red&quot; ## [1] FALSE We can also multiply logical values by numeric values (i.e. numbers) and R will interpret a TRUE as being 1 and a FALSE as being 0. 1.3.3 Assignment Consider the following line of code: length(c(&quot;Hello&quot;,&quot;World&quot;)) - 1 ## [1] 1 There are many steps happening here. First,the c function took in the two arguments \"Hello\" and \"World\", realised they were characters (rather than numbers), put them together into a vector (that’s its job) and then passed that vector as a single argument to the length function. Finally, we subtracted 1 from the result. Now consider the following line of code: x &lt;- c(&quot;Hello&quot;,&quot;World&quot;) length(x) - 1 ## [1] 1 Much easier to read and follow. We created the vector in the same way, but then we used the &lt;- operator to put it in a box called x. On the next line, we put that box into the length function, and then subtracted the 1. This box is called a variable, and if you run this line of code, you’ll notice that the x variable now populated our Workspace pane in the Top-Right. The Workspace pane tells us the data type (chr is short for character) and we can tell that the length is 2 from the bit that says [1:2] (we’ll unravel this soon, too). Being able to assign variables is a kay part of using R (and again, programming in general). Once these variables have been assigned, we can use them again and again, and re-assign them as and when we need, and even use them to re-assign themselves! x &lt;- 2 x + 2 ## [1] 4 x + 3 ## [1] 5 x &lt;- x + 1 x ## [1] 3 1.3.4 Subsetting Now, x in our Workspace pane is just a single number (not a vector). But we can obviously change that x &lt;- c(2,4,6,8,10) We’re once again told it’s data type (this time its an int), and its length is 5 from the [1:5]. When we’re working with vectors, sometimes we need to grab out just some of the elements and not all of them. For this, we use extraction. If we want to pull out the third element of a vector, we enclose that number in square brackets, [ and ], to tell R that we are extracting data from a vector: x[3]. We can also pass a vector into the subsetting to grab more than one element: x[c(1,2,3)] ## [1] 2 4 6 And, since we can pass in a vector, think about what the following does. x[1:3] ## [1] 2 4 6 The next easiest way to subset is to use a logical vector that is the same length as the vector we are subsetting, and R will return any element which is TRUE and ignore elements which are FALSE. x[c(T,T,F,F,T)] ## [1] 2 4 10 y &lt;- c(&quot;red&quot;,&quot;blue&quot;,&quot;yellow&quot;,&quot;green&quot;,&quot;red&quot;) x[y==&quot;red&quot;] ## [1] 2 10 Finally, we can also subset to remove elements we’re not interested in x[-3] ## [1] 2 4 8 10 x[-c(2,3)] ## [1] 2 8 10 Assignment and Subsetting can also be combined to change certain elements in our vector x[3] &lt;- 2 x ## [1] 2 4 2 8 10 x[4:5] &lt;- 0 x ## [1] 2 4 2 0 0 If we have a patrticularly large vector, we can also look at just the first 6 values, by using the function head() (or conversely, tails() to show us the last 6), as we’ll see in the next section. Do you see what the [1:5] means in the Workspace pane? The 1:5 is the possible values that we can subset x with. 1.4 Statistics 1.4.1 Data Now that we have the basics, we can move onto some statistical work using data. Normally, you would use a function such as read.csv() to read in our data. This function can read in data that is formatted as a csv file (or comma-separated). There are also ways to import more complicated data, such as from excel, but these don’t come built-in with R (we need additional stuff called packages to load other data). An important note when loading data using read.csv() or a similar function is that the file directory needs to use forward slashes (/) rather than backward slashes (\\). Basically, copy the folder directory, but replace the slashes: dat &lt;- read.csv(&quot;M:\\Documents\\My Data.csv&quot;) # This line won&#39;t work dat &lt;- read.csv(&quot;M:/Documents/My Data.csv&quot;) # This works! That’s how you get your data into R. Today, we’re going to begin by loading up a built in dataset, called iris, which is a dataset containing data about flowers. data(&quot;iris&quot;) head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa The function data() can be used to load up a Built-in datasets (useful for examples and practising!). As previously said, head() now displays the first 6 rows of our data, which is a table (known in R as a data.frame). Double click on iris in the Workspace and a new tab will open up in place of the Script pane. This shows the full table and allows us to scroll. There are five variables in iris: Sepal.Length, Sepal.Width, Petal.Length, Petal.Width and Species (note the capitalisation!). Similar to a vector, we can subset in a data.frame using the square brackets, however since iris is a table, R needs two values, one for the row and a second for the column, separated by a comma (again, we can extract multiple rows/columns by using vectors) iris[2,3] #Returns the value in the second row and the third column ## [1] 1.4 iris[1:10,1:3] #Returns the values in the first ten rows and the first three columns ## Sepal.Length Sepal.Width Petal.Length ## 1 5.1 3.5 1.4 ## 2 4.9 3.0 1.4 ## 3 4.7 3.2 1.3 ## 4 4.6 3.1 1.5 ## 5 5.0 3.6 1.4 ## 6 5.4 3.9 1.7 ## 7 4.6 3.4 1.4 ## 8 5.0 3.4 1.5 ## 9 4.4 2.9 1.4 ## 10 4.9 3.1 1.5 iris[1:5,c(3,4,5)] #Returns the first five rows and the 3rd, 4th and 5th columns ## Petal.Length Petal.Width Species ## 1 1.4 0.2 setosa ## 2 1.4 0.2 setosa ## 3 1.3 0.2 setosa ## 4 1.5 0.2 setosa ## 5 1.4 0.2 setosa The way R structures data.frames is that each variable within the data.frame is it’s own vector of values with the restriction that all the vectors have to be the same length, i.e. the number of rows in the table. Which means, we can pull vectors out using the $ operator: iris$Sepal.Length #Notice that RStudio pops up with the available variable names here ## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 ## [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0 ## [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5 ## [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1 ## [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5 ## [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3 ## [109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2 ## [127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 ## [145] 6.7 6.7 6.3 6.5 6.2 5.9 And these vectors can be used in the exact same way as other vectors, e.g iris$Sepal.Width[1:15] ## [1] 3.5 3.0 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 3.7 3.4 3.0 3.0 4.0 As previoiusly, we can also edit individual values (known as cells) within a dataset using the subsetting and assignment. 1.4.2 Describing our data Here are a few functions that can be useful for describing your data: mean(iris$Sepal.Length) #Gives the arithmetic mean of the variable Sepal.Length within the data.frame iris ## [1] 5.843333 sd(iris$Sepal.Width) #Standard Deviation of the variable ## [1] 0.4358663 table(iris$Species) #Provides a count of each unique value of the variable ## ## setosa versicolor virginica ## 50 50 50 range(iris$Petal.Length) #Gets the minimum and maximum values, these can also be extracted using min() and max() ## [1] 1.0 6.9 If we want to find out the median and/or percentiles of a variable we use the quantile() function, and we can specify which percentiles we want to find in the vector. We do this by specifying the percentiles as decimal values (i.e. between 0 and 1) in another vector and pass both arguments to the function. Once again, remember we separate arguments by a comma. Quantiles &lt;- c(0.05,0.5,0.95) quantile(iris$Petal.Width, Quantiles) ## 5% 50% 95% ## 0.2 1.3 2.3 We did not need to define Quantiles beforehand here, but it certainly makes the code look a little neater than this: quantiles(iris$Petal.Width,c(0.05,0.5,0.95)). We can also combine subsetting to pull out descriptive statistics based on pre-requisites. What does this do? mean(iris$Sepal.Length[iris$Species == &quot;setosa&quot;]) ## [1] 5.006 From R’s perspective: Create a logical vector that is the same length as the vector iris$Species (i.e. same as the number of rows in the table), to indicate whether iris$Species == \"setosa\" Pull out the subset of iris$Sepal.Length such that the previous vector is TRUE Calculate the mean of this vector. R works from the inside outwards when it comes to functions like this. Not the most legible way to understand the code afterwards (but we’ll learn how to fix this next week!) 1.4.3 Plotting The basic function for plotting in R is the plot() function, and is used very intuitively for scatter plots: plot(iris$Sepal.Length,iris$SSepal.Width) However, this is pretty boring. Let’s add some colour and give appropriate labels plot(x = iris$Sepal.Length, y = iris$SSepal.Width, col = iris$Species, main = &quot;Plot of Sepal Length vs Width&quot;, sub = &quot;Stratified by Species&quot;, xlab = &quot;Sepal Length&quot;, ylab = &quot;Sepal Width&quot;, ) Here, we changed the plot to use the variable Species as an indicator of which colur to use for each point. We could have just used col=\"red\" to tell R to plot them all red, but that’s not as useful to distinguish! We’ve done something new here, we supplied our arguments to the function as a named argument. This is because not all of these arguments are needed (see the previous one). If we don’t name them, R assumes the first argument is x and the second is y (which is a good assumption to make). However, since they’re not needed, we need to tell R which is which (it can’t rely on them being supplied in the same order everytime). If we don’t specify them, R will choose default values, which can be seen in the help file (?plot). 1.5 Probabilities 1.5.1 Data Distributions Now that we can plot, it means we can visualise a key aspect of statistics: the probability density function (pdf) and the cumulative density function (cdf) of a probability distribution.To demonstrate, I’m going to use the Normal distribution. The Normal distribution is one of the most commonly used distributions due to its symmetry and the fact that many natural variables can be modelled by it. The Standard Normal distribution is when the values have been standardised so that the mean is 0 and the sd is 1. 1.5.1.1 Density Function x &lt;- seq(-3,3,0.01) #Create a vector form -3 to 3 with steps of 0.01 y &lt;- dnorm(x, mean=0, sd=1) #Here is the new function plot(x, y, type=&quot;l&quot;,ylab=&quot;Density&quot;) # The argument type = &quot;l&quot; means we want a line plot The function dnorm is the probability density function (pdf) for the Normal distribution, usually written as \\(f(x)\\). Higher density means more values are clustered around there and a lower density means there are less. the two arguments, mean and sd can be defined to match our data. For the Standard Normal, the pdf is defined by this nasty looking formula: \\[ f(x) = \\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{1}{2}x^2} \\] Let’s say we have a clinical trial with two arms; a control arm and a treatment arm. The treatment arm recieves a drug that may be able to reduce systolic blood pressure (SBP). After the trial is over, we are told that for the control arm, the mean SBP is 160 with an sd of 3 and the treatment arm has an SBP of 155 with an sd of 4. Assuming they are Normally distributed (a fair assumption if we have enough patients), then we can plot the density of the two distributions on the same plot x &lt;- seq(145, 170, 0.1) #Broad range of values to cover both groups control.y &lt;- dnorm(x, mean = 160, sd = 3) #Get the y values for the control arm treat.y &lt;- dnorm(x, mean = 155, sd = 4) #Get the y values for the treatment arm plot(x,control.y,col=&quot;red&quot;,type=&quot;l&quot;,ylab=&quot;Density&quot;,xlab=&quot;SBP&quot;) #Remember what all these arguments do? lines(x,treat.y,col=&quot;blue&quot;) #the lines() function *adds* a line to a previous plot Loooking at the two plots, there is a lot of overlap so it would be difficult to say that this drug works. What happens if you change the mean or sd for either of the arms? 1.5.1.2 Probability Function x &lt;- seq(-3,3,0.01) y &lt;- pnorm(x, mean=0, sd=1) plot(x, y, type=&quot;l&quot;,ylab=&quot;Probability&quot;) The function pnorm is the cumulative density function (cdf), usually written as \\(F(x)\\). It is defined as the area under the pdf up to the value (i.e. its integral). It is used to find the probability that something is less than that value (assuming it follows a Normal Distribution). \\[ F(x) = \\int_{-\\infty}^x f(u) \\;\\textrm{d}u = \\textrm{Prob}\\left(X &lt; x\\right) \\] This can answer questions such as: “If we assume the height of males at a university follows a Normal distribution with a mean of 175.5cm and a standard deviation of 6.5cm. What is the probability that a male student chosen at random is taller than 180cm?” p &lt;- pnorm(180, mean = 175.5, sd = 6.5) #This is the probability that a student is *shorter* than 180cm 1 - p #The probability that they are *taller* than 180cm ## [1] 0.2443721 1.5.1.3 Quantile Function p &lt;- seq(0,1,0.01) #This time, we need the input to be between 0 and 1 y &lt;- qnorm(p,mean = 0, sd = 1) plot(p,y,type=&quot;l&quot;) The function qnorm() is the inverse of the pnorm() function. For a given probability, it can provide the associated value. From the previous example, what height are 95% of the students shorter than? p &lt;- 0.95 qnorm(p, mean = 175.5, sd = 6.5) ## [1] 186.1915 So 95% of the male students in the school are shorter than 186.2cm. 1.5.1.4 Random Function z &lt;- rnorm(100, mean = 0, sd = 1) head(z) ## [1] -1.0184620 -0.3896440 0.1468796 -0.4595894 -1.7630333 -1.0448115 If you were to print out the z variable, you’d see 100 random numbers. The first argument we pass to the function rnorm() tells it how many random numbers to generate. These random numbers have been drawn from the Standard Normal distribution and so they will follow that distribution. We can see this with the following plot: hist(z) This histogram shows where all the values in the data in z lie. We group them into bins and then count how many are in each bin. This histogram should roughly look like the pdf of the distribution. However, due to the random nature and the fact that there are only 100, it’s not very close to it’s underlying distribution. If we increase the number of random numbers to 10,000, it’ll look closer. z &lt;- rnorm(10000) #This time, we&#39;re not specifying the mean or sd for either rnorm or dnorm x &lt;- seq(-3,3,0.01) y &lt;- dnorm(x) # By default, R will use mean = 0 and sd = 1. hist(z, probability = T) #This tells R that we want the probability of each bin, rather than the count (i.e. count/total) lines(x,y) 1.5.1.4.1 Other Distributions So far, for this section, we’ve used the Normal distribution. However, there is a whole bunch of other distributions that we could use, and they all follow the same formatting style: dxxxx(x,...) gives the probability density function of the distribution at x pxxxx(x,...) gives the cumulative density function of the distribution at x qxxxx(p,...) gives the inverse of the cdf of the distribution at p rxxxx(n,...) generates n random numbers that follow the distribution A few examples can be seen in the below plots: "],
["tidyverse-for-tidy-data.html", "2 Tidyverse for Tidy Data 2.1 Packages 2.2 The Pipe 2.3 Loading Data 2.4 Changing our data 2.5 Combining data 2.6 The Cheat Sheets", " 2 Tidyverse for Tidy Data 2.1 Packages R is designed to be a modular approach to statistical analysis and is open-source and allows the addition of packages. This means that the version of R you download is the basic version of it and we can download packages which contian more advanced functions. Think of it like DLC, but for statistics (and much like R it is still free!) These packages are built by other R users and can be downloaded from a repository called CRAN (Comprehensive R Archive Network). 2.1.1 Installing packages The first package we’re going to download and install is the tidyverse package (which actually imports/installs a bunch of other packages). The command to install a new packages is: install.packages(&quot;tidyverse&quot;) This function will search CRAN for the package called \"tidyverse\" and install it into our own package repository. Note that this needs to be in quotes as this is a string that R will search for. It also downloads and installs all the other packages that tidyverse uses. As it’s installing, you’ll see it run through all these packages (e.g. broom, ggplot2,tidyr), we’ll get to these later. If you’re running this on your home computer and have full admin rights, then this installation should go fine (it just might take a while). However if you don’t have full admin rights, then you might need to use the lock=F argument like so: install.packages(\"tidyverse\",lock=F), for example on a university computer you need to install packages this way. If the installation fails, try this way. You can see the currently installed packages inthe Viewer pane under the Packages tab. If you click on the name of a package in here, it will bring up a Help file (still in the Viewer pane) for that package, including a list of functions contained in that package (which link to their Help Files). Some packages include links to vignettes/documentation regarding the package. 2.1.2 Documentation As well as storing the actual package files, CRAN also stores documentation about the package. This includes the Help files that get installed along with the packages. CRAN homepages for packages are standardised and all look the same with (roughly) the same information. Let’s have a look at the CRAN page for the tidyverse. Most of what we see here is for fairly advanced R users, so we’re going to ignore a lot of it (until you get better). At the top, you can see the name of the package and a quick blurb about what it’s for. There are also a bunch of links to other packages that the current package uses. Under the Downloads heading, you can see the Reference manual and the Vignettes. The Reference manual for a package contains a list of all of the functions that are in that package, and information about their use. This information is the same information that is contained in the ? Help files that is downloaded into R. This can be useful if you can’t remember the name of a function, but you know it’s in a certain package. The Vignettes are more of a user guide. They’re usually written by the package author and contains information on how to use the package. Kind of like an instruction manual, whereas the reference manual is more like the glossary. Packages don’t always have vignettes, but when they do, I highly recomend reading them. 2.1.3 Loading packages So, we’ve installed a package, but we’re not actually using it. Once a package has been installed it is stored on our system and we only need to do this once. But, we also need to load the package into our current R session. (Note that this time, we don’t need quotation marks) We now have access to all of the functions contained within the core bundle of tidyverse packages (listed in the console under Attaching packages. This means that by installing and loading the tidyverse package, we’ve actually installed and loaded these other packages (e.g. ggplot2 and dplyr). Let’s get started! 2.2 The Pipe One of the most important changes that comes with the tidyverse is the addition of the Pipe: %&gt;%. It’s a new operator that comes with the dplyr package (originally from the magrittr pckage) and it allows us to completely change how we use functions. It can make our code much easier to read, particularly when writing complicated series of functions. For example: #Written as single line: log(sqrt(sum(runif(20)))) #Spread over multiple lines x &lt;- 20 x &lt;- runif(x) x &lt;- sum(x) x &lt;- sqrt(x) x &lt;- log(x) x #Written with pipes: 20 %&gt;% runif() %&gt;% sum() %&gt;% sqrt() %&gt;% log() All three of thes examples perform the same actions in the same order. But that first line is really difficult to read. It’s hard to see what functions are happening and which brackets are associated with which function. If we wanted to add 3 after the sum() function, it would be hard to see where to put it. In the single line version, we are working from the inside out. This gets easier to read in the version where we spread it across multiple lines since what we’re doing is now in order. But this is prone to mistakes. What if we type z instead of x in a function call or an assignment call? The piped version gets rid of this risk and duplicated code (x &lt;- on every line). I’ve chosen to spread my command over multiple lines to make it easier to read and to indent each new line (RStudio actually does this automatically for you), this makes my code look neater and much easier to read. What the pipe does is allow us to pipe our answer into the next function as the first argument. We can then chain them together as above to make things much easier to read. This changes our syntax a little bit. The following lines perform the same thing: f(a,b,c,d) a %&gt;% f(b,c,d) And with chaining: f(g(a,b),c,d) a %&gt;% g(b) %&gt;% f(c,d) If your function only takes a single argument, then you don’t even need to include the brackets: 20 %&gt;% runif %&gt;% sum %&gt;% sqrt %&gt;% log ## [1] 1.105514 The shortcut to quickly enter this in RStudio is Ctrl/Cmd + Alt + M 2.3 Loading Data I’ve uploaded a messy dataset online for us to use today. Right click the link and then download the file. Save it somewhere useful (maybe in a new folder). In R (as well as many programming languages), we have something called the working directory. We can see this if we click on the Files tab in the Viewer pane (bottom right). This shows us all the files in our current directory (note, this might not be our working directory if we’ve clicked around a bit). We can find out our working directory by using the command getwd() and we can change it using the setwd() command. It can be tricky to remember what the directory were trying to find its, so we can use a file explorer window to find it. In the top menu, click Session &gt; Set Working Directory &gt; Choose Directory (or press Ctrl/Cmd + Shift + H). Find the folder where you’ve just saved the file and set it as our working directory. You’ll notice that R Studio actually sent the setwd() command to the Console for us anyway. If you want, you can copy and paste that into your script for use later (just remember to remove the &gt; symbol or it won’t run from the Script). If you didn’t want to download the file, you can also load it straight from the web: dat &lt;- read_csv(&quot;data/data_anthro.csv&quot;) ## Parsed with column specification: ## cols( ## ID = col_character(), ## DOB = col_character(), ## Gender = col_character(), ## Ht = col_character(), ## Wgt = col_character() ## ) This read_csv() function is contained in the readr package. There is a built in function in R that allows us to bring in csv files, but it’s messier. We’re in the tidyverse now! This has given a bit of an output. read_csv tries to guess what data types columns/variables within this dataset are. We can suppress this message with the argument col_types = col(), or we can define what we want them to be by passing the data types as a vector (d=double, c=character,l=logical) col_types=c(\"c\",\"c\",\"c\",\"c\",\"c\"). Let’s have a look at this data. Previously, we needed to use the head() function to just look at the top few rows. But that was when we were using data.frame structure from the basic R package. read_csv() loads the data and stores it in a tibble format. This is essentially the same as a data.frame (and can be used in the same way), but provides a bit more information and consistency and only prints the first few rows: dat ## # A tibble: 150 x 5 ## ID DOB Gender Ht Wgt ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 001 22/03/1965 m 5 6 7 1 ## 2 002 17/04/1977 f 5 9 11 0 ## 3 003 24/07/1966 f 5 4 9 8 ## 4 004 22/02/1985 Female 5 7 11 1 ## 5 005 30/07/1985 M 6 0 10 10 ## 6 006 09/07/1987 male 6 2 11 12 ## 7 007 23/01/1995 female 5 10 10 2 ## 8 008 31/12/1992 M 6 3 12 1 ## 9 009 24/01/1952 Male 5 4 7 10 ## 10 010 11/06/1953 F 5 2 8 6 ## # ... with 140 more rows R now tells us that the tibble has 150 rows and 5 columns, and as well as giving us the names of the variables in the data, it also tells us their types (at the moment, they’re all &lt;chr&gt;, but some of these will change as we go on) and at the bottom, we’re told that there are 140 more rows. If we had a lot of columns in this data, R would only show us the first few columns (as many can fit in the screen) and tell us at the bottom what the extra columns are (names and data types). 2.3.1 Messy Data! This data is quite messy. There are some things we need to fix. First thing to do would be to list out everything we need to fix. I would prefer ID to be a number (although this is not always true) DOB is a character. This is supposed to be a date. Can R store dates? OF COURSE IT CAN! The next two columns are Ht and Wgt, and are supposed to be Height and Weight. We’ll fix those names Height and weight are stored as feet/inches and stone/pounds. This is inconvenient. We want consistecy, so we want to change them to cm and kg. Gender is also inconsitent some are words (male/female) and lower/uppercase single letters. We need to standardise this. 2.4 Changing our data We could edit this data in excel and go through one cell at a time, but if we have a big data set, this is going to be difficult. Let’s get R to do it for us. The advantage of doing it all in R is that our Raw data (the original file) doesn’t need to be changed. We write our code in a Script to process the data and then at the end, we can save our data as a new file, or just our outputs (i.e. our models). 2.4.1 The mutate() function The dplyr package provides us with the mutate() function, which is incredibly useful for editing data as we go, and is designed to be used with the pipe. Let’s use it, along with the as.numeric() function to convert the ID variable into a number. dat %&gt;% mutate(ID = as.numeric(ID)) ## # A tibble: 150 x 5 ## ID DOB Gender Ht Wgt ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 22/03/1965 m 5 6 7 1 ## 2 2 17/04/1977 f 5 9 11 0 ## 3 3 24/07/1966 f 5 4 9 8 ## 4 4 22/02/1985 Female 5 7 11 1 ## 5 5 30/07/1985 M 6 0 10 10 ## 6 6 09/07/1987 male 6 2 11 12 ## 7 7 23/01/1995 female 5 10 10 2 ## 8 8 31/12/1992 M 6 3 12 1 ## 9 9 24/01/1952 Male 5 4 7 10 ## 10 10 11/06/1953 F 5 2 8 6 ## # ... with 140 more rows Exactly as we needed, ID is now a number (&lt;dbl&gt;, short for double, which just means it can store a big number, a relic of old programming). The mutate() function takes in a tibble as it’s first argument (remember, this is what the pipe is doing) and changes it depending on whatever other information is passed to it. If the variable we put in already exists, it is overwritten, if not a new column is created. We can edit more than one variable at a time this way and create new variables and the variables are created/edited in order. dat %&gt;% mutate(x = runif(150), #Remember this function? y = runif(150), x = x + y) ## # A tibble: 150 x 7 ## ID DOB Gender Ht Wgt x y ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 001 22/03/1965 m 5 6 7 1 1.06 0.379 ## 2 002 17/04/1977 f 5 9 11 0 1.39 0.712 ## 3 003 24/07/1966 f 5 4 9 8 1.36 0.858 ## 4 004 22/02/1985 Female 5 7 11 1 1.66 0.931 ## 5 005 30/07/1985 M 6 0 10 10 0.726 0.258 ## 6 006 09/07/1987 male 6 2 11 12 0.603 0.141 ## 7 007 23/01/1995 female 5 10 10 2 0.641 0.599 ## 8 008 31/12/1992 M 6 3 12 1 0.974 0.194 ## 9 009 24/01/1952 Male 5 4 7 10 0.555 0.365 ## 10 010 11/06/1953 F 5 2 8 6 0.538 0.478 ## # ... with 140 more rows Note that this is the same as running mutate(dat,x=runif(150),y=runif(150),x=x+y). Right now, we’ve not stored the output from the previous mutate() call, dat is still as it was when we loaded it with the ID variable stored as a character. See: dat ## # A tibble: 150 x 5 ## ID DOB Gender Ht Wgt ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 001 22/03/1965 m 5 6 7 1 ## 2 002 17/04/1977 f 5 9 11 0 ## 3 003 24/07/1966 f 5 4 9 8 ## 4 004 22/02/1985 Female 5 7 11 1 ## 5 005 30/07/1985 M 6 0 10 10 ## 6 006 09/07/1987 male 6 2 11 12 ## 7 007 23/01/1995 female 5 10 10 2 ## 8 008 31/12/1992 M 6 3 12 1 ## 9 009 24/01/1952 Male 5 4 7 10 ## 10 010 11/06/1953 F 5 2 8 6 ## # ... with 140 more rows 2.4.2 Neat code For now, let’s clear out our Script pane to keep ourselves organised, and eliminate the code that we don’t need. Copy this into your Script pane and run it all (Ctrl/Cmd + A will select all the code in the Script pane and Ctrl/Cmd + Enter will run it all) rm(list=ls()) #Load up my libraries library(tidyverse) #Load up my data dat &lt;- read_csv(&quot;data/data_anthro.csv&quot;) #Edit the dat file dat_clean &lt;- dat %&gt;% mutate(ID = as.numeric(ID)) #Turn ID into numeric dat_clean I’ve added a function as the first line rm(list=ls()) which will clear out our workspace and get rid of any variables that have been created. I’ve also added annotations with the # symbol. R won’t run anything in a line that is preceded by the # symbol (and it’ll even colour code it as well), this allows you to make notes (either to yourself or others) explaining what your code is actually doing. This isn’t always necessary if it’s obvious, but it can be useful to keep track of things. Annotations are voluntary. We don’t have to put them in there, but they really help when you’re reading over code that you’ve not used in a while, or you’re sending it to someone else. It’s much easier to annotate and make your code as readable as possible than it is to stand there explaining your code to someone who has never seen it before. We’ve also stored the cleaned dat dataset as dat_clean 2.4.3 The rename() function The dplyr package also provides us with the rename function, which allows us to rename some of the variables. This can make it easier to interpret what the variables are. Coming up with clear and concise names is very good practice for budding coders. As we mentioned earlier, with the %&gt;% pipe, we can chain commands together, so that’s what we’re going to start doing. In the end, our tidying of the data is going to be one long chain of functions, but it should be clear what we’ve done, and in what order. After it’s done, R will store the output of everything into the dat_clean variable. So, let’s add a rename() command to our dat cleaning chain. dat_clean &lt;- dat %&gt;% mutate(ID = as.numeric(ID)) %&gt;% #Turn ID into numeric rename(Height = Ht, Weight = Wgt) #Rename some variables dat_clean ## # A tibble: 150 x 5 ## ID DOB Gender Height Weight ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 22/03/1965 m 5 6 7 1 ## 2 2 17/04/1977 f 5 9 11 0 ## 3 3 24/07/1966 f 5 4 9 8 ## 4 4 22/02/1985 Female 5 7 11 1 ## 5 5 30/07/1985 M 6 0 10 10 ## 6 6 09/07/1987 male 6 2 11 12 ## 7 7 23/01/1995 female 5 10 10 2 ## 8 8 31/12/1992 M 6 3 12 1 ## 9 9 24/01/1952 Male 5 4 7 10 ## 10 10 11/06/1953 F 5 2 8 6 ## # ... with 140 more rows The syntax here is just new-name = old-name. Now the variables Ht and Wgt are completely gone from dat, and we have new variables Height and Weight in their place. That’s two out of our five problems solved. 2.4.4 The recode() function The Gender variable is still a bit of mess. Let’s take a look. This time, we’re just going to put this in the console. table(dat$Gender) ## ## f F female Female m M male ## 13 26 18 18 12 19 22 ## Male Non-Binary ## 18 4 We’re used the $ operator to access the Gender variable inside the dat tibble, and then ran the table() function to get a count of how often each of the values appear in the variable. An interesting side note is that when we’ve been using the variables in dat within our tidyverse functions, we’ve not needed to use this $ operator, e.g. you would expect to have to do something like dat %&gt;% mutate(dat$ID = as.numeric(dat$ID), but we didn’t, we just needed: dat %&gt;% mutate(ID = as.numeric(ID)). Another advantage of the tidyverse. We as humans can tell what each of these entries means. Some of them mean Male and some mean Female. But R can’t discern that. We’re gonna lump them together by converting all the relevant values into “Male” or “Female”. We can do this using the recode() function inside the mutate() function. dat_clean &lt;- dat %&gt;% mutate(ID = as.numeric(ID)) %&gt;% #Turn ID into numeric rename(Height = Ht, Weight = Wgt) %&gt;% #Rename some variables mutate(Gender = recode(Gender, #Tidy up Gender m = &quot;Male&quot;, male = &quot;Male&quot;, M = &quot;Male&quot;, #Males f = &quot;Female&quot;, female = &quot;Female&quot;, F = &quot;Female&quot;)) #Females dat_clean ## # A tibble: 150 x 5 ## ID DOB Gender Height Weight ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 22/03/1965 Male 5 6 7 1 ## 2 2 17/04/1977 Female 5 9 11 0 ## 3 3 24/07/1966 Female 5 4 9 8 ## 4 4 22/02/1985 Female 5 7 11 1 ## 5 5 30/07/1985 Male 6 0 10 10 ## 6 6 09/07/1987 Male 6 2 11 12 ## 7 7 23/01/1995 Female 5 10 10 2 ## 8 8 31/12/1992 Male 6 3 12 1 ## 9 9 24/01/1952 Male 5 4 7 10 ## 10 10 11/06/1953 Female 5 2 8 6 ## # ... with 140 more rows The first argument is actually the vector that we are recoding, Gender. Since we’re only performing the one function here, we’re not going to pipe as it’s still pretty neat as it is (thanks to the neat indentation oriented formatting). Confusingly, this is written backwards to the rename() function, so we need old-name = new-name and the new name has to be in quotes (because it is a string), but other than that, it’s pretty straight forward. If we’re recoding a string that has spaces or that starts with a number, we need to put them in between backticks. You’ll be used to the single quote or apostrophe (’) and double quote (\"), but in R, we sometimes need to use the backtick as a quotation mark (`). The backtick is usually located to the left of the 1 button on your keyboard (yes, that button is finally useful!) x &lt;- c(&quot;One&quot;,&quot;Two&quot;,&quot;3&quot;,&quot;Fo ur&quot;) recode(x,`3` = &quot;Three&quot;,`Fo ur` = &quot;Four&quot;) ## [1] &quot;One&quot; &quot;Two&quot; &quot;Three&quot; &quot;Four&quot; Technically, the recode() function can be used with a numeric vectors rather than a character vector, but it is much easier not to (mostly because R can store different types of numbers, eg double,&lt;dbl&gt; is different from an integer &lt;int&gt;, but we’re not going to get into that here, just don’ do it). 2.4.5 The if_else() function The recode() function is pretty useful for a lot of circumstances, but it still looks a little clunky in our code. We can use the if_else() function to make R make a decision. Basically, if something is true do this thing, if it’s false, do the other thing. x &lt;- c(&quot;One&quot;,&quot;Two&quot;,&quot;3&quot;,&quot;Four&quot;) if_else(x == &quot;3&quot;,&quot;Three&quot;,x) ## [1] &quot;One&quot; &quot;Two&quot; &quot;Three&quot; &quot;Four&quot; For our vector, it evaluates the first argument (x==3 into a logical vector) and then if it’s TRUE, it uses the second argument and if it’s FALSE uses the third argument. A lot of the time, the third argument will just be the original vector (so we only change it if the logical statement is TRUE). These conditional arguments can also be vectors, in which case R will match them up and keep everything in the right order. We’re also going to introduce a new operator, the %in% operator. Remember operators have something on the left and something on the right. The %in% operator checks if the things in the vector on the left are in the vector on the right x &lt;- c(1,2,3,4,5,6) x %in% c(2,4,6) ## [1] FALSE TRUE FALSE TRUE FALSE TRUE For every element in x, we check whether it is in the vector on the right. If it is, it returns TRUE, otherwise, it returns FALSE. We can use this instead of the previous recode dat_clean &lt;- dat %&gt;% mutate(ID = as.numeric(ID)) %&gt;% #Turn ID into numeric rename(Height = Ht, Weight = Wgt) %&gt;% #Rename some variables mutate(Gender = if_else(Gender %in% c(&quot;m&quot;,&quot;M&quot;,&quot;male&quot;),&quot;Male&quot;,Gender), #Tidy up Gender Gender = if_else(Gender %in% c(&quot;f&quot;,&quot;F&quot;,&quot;female&quot;),&quot;Female&quot;,Gender)) dat_clean ## # A tibble: 150 x 5 ## ID DOB Gender Height Weight ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 22/03/1965 Male 5 6 7 1 ## 2 2 17/04/1977 Female 5 9 11 0 ## 3 3 24/07/1966 Female 5 4 9 8 ## 4 4 22/02/1985 Female 5 7 11 1 ## 5 5 30/07/1985 Male 6 0 10 10 ## 6 6 09/07/1987 Male 6 2 11 12 ## 7 7 23/01/1995 Female 5 10 10 2 ## 8 8 31/12/1992 Male 6 3 12 1 ## 9 9 24/01/1952 Male 5 4 7 10 ## 10 10 11/06/1953 Female 5 2 8 6 ## # ... with 140 more rows There are plenty of situations where recode() is better than if_else(). Since we’re wanting to turn a lot of values into a few simpler ones, the if_else() function is better. If we’re just wanting to rename the values in our variable, then recode() works better. For example, if all the values were either “M”, “F” or “N” and we want them to be “Male”, “Female” or “Non-Binary”, then recode() would be the better option. But remember that “Better” is often subjective. These commands do the same thing, but whichever you understand better should be the one you use! 2.4.6 The case_when() function We’ve converted the recode() function into a pair of if_else() functions. Not too bad when we’re just doing two, but if we needed to look at more cases, this could get complicated. And complicated means prone to errors. We can use the case_when() function for this: dat_clean &lt;- dat %&gt;% mutate(ID = as.numeric(ID)) %&gt;% #Turn ID into numeric rename(Height = Ht, Weight = Wgt) %&gt;% #Rename some variables mutate(Gender = case_when(Gender %in% c(&quot;m&quot;,&quot;M&quot;,&quot;male&quot;) ~ &quot;Male&quot;, #Tidy up Gender Gender %in% c(&quot;f&quot;,&quot;F&quot;,&quot;female&quot;) ~ &quot;Female&quot;, T ~ Gender)) dat_clean ## # A tibble: 150 x 5 ## ID DOB Gender Height Weight ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 22/03/1965 Male 5 6 7 1 ## 2 2 17/04/1977 Female 5 9 11 0 ## 3 3 24/07/1966 Female 5 4 9 8 ## 4 4 22/02/1985 Female 5 7 11 1 ## 5 5 30/07/1985 Male 6 0 10 10 ## 6 6 09/07/1987 Male 6 2 11 12 ## 7 7 23/01/1995 Female 5 10 10 2 ## 8 8 31/12/1992 Male 6 3 12 1 ## 9 9 24/01/1952 Male 5 4 7 10 ## 10 10 11/06/1953 Female 5 2 8 6 ## # ... with 140 more rows Each argument in the case_when() function is a logical, just like in the if_else() statement, followed by the ~ symbol, and then the result that we want to use in that case. R evaluates each of the conditional statements in order, this means that if two statements are correct (for your given data), R will return the first choice. This is also why we finish with a T ~ Gender to give the case_when() function a default option, if none of the other statements are TRUE, then this last one is definitely (and literally) TRUE. Here’s a simpler example to show this sequential evaluation: x &lt;- 1:10 case_when(x &lt; 3 ~ &quot;small&quot;, #This is true for 1 &amp; 2 x &lt; 7 ~ &quot;medium&quot;, #This is true for 1, 2, 3, 4, 5 and 6, BUT 1 &amp; 2 have already gone. T ~ &quot;large&quot;) #Everything else (7, 8 &amp; 9) get this result ## [1] &quot;small&quot; &quot;small&quot; &quot;medium&quot; &quot;medium&quot; &quot;medium&quot; &quot;medium&quot; &quot;large&quot; &quot;large&quot; ## [9] &quot;large&quot; &quot;large&quot; For our purposes, we can use any of the previous options: recode(), if_else() or case_when(). It’s upto personal choice and style. Which do you find the easiest to understand? Which makes the most sense and is clearer for you. Whichever one it is, keep that one. We’re going to look at one final way to do this soon 2.4.7 Boolean Logic The last few bits involved evaluating a conditional statement (i.e logical vectors), sometimes, we need to check a few different statements at once. We might need them both to be true, or just one of them, or neither of them. We can use operators to combine logical vectors (just like we use operators for numeric vectors e.g c(5,4) + c(3,2)) x &lt;- c(T,T,F,F) y &lt;- c(T,F,T,F) x &amp; y #AND opertor, both the left and right must be TRUE ## [1] TRUE FALSE FALSE FALSE x | y #OR operator, either the left or the right need to be TRUE ## [1] TRUE TRUE TRUE FALSE xor(x,y) #Exclusive OR, only one can be TRUE ## [1] FALSE TRUE TRUE FALSE Obviously the last one, xor() is a function and not an operator, but it can still come in handy for our if_else() and case_when() functions. 2.4.8 The factor() function In data terms, we’d say that the Gender variable is categorical. Since we have a categorical data, it would make sense that we also want to store it in our tibble as such. Let’s do that! Underneath, R stores a factor as a number with an associated vector of levels, which is (usually) a character. dat_clean &lt;- dat %&gt;% mutate(ID = as.numeric(ID)) %&gt;% #Turn ID into numeric rename(Height = Ht, Weight = Wgt) %&gt;% #Rename some variables mutate(Gender = case_when(Gender %in% c(&quot;m&quot;,&quot;M&quot;,&quot;male&quot;) ~ &quot;Male&quot;, Gender %in% c(&quot;f&quot;,&quot;F&quot;,&quot;female&quot;) ~ &quot;Female&quot;, T ~ Gender), #Tidy up Gender Gender = factor(Gender)) dat_clean ## # A tibble: 150 x 5 ## ID DOB Gender Height Weight ## &lt;dbl&gt; &lt;chr&gt; &lt;fct&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 22/03/1965 Male 5 6 7 1 ## 2 2 17/04/1977 Female 5 9 11 0 ## 3 3 24/07/1966 Female 5 4 9 8 ## 4 4 22/02/1985 Female 5 7 11 1 ## 5 5 30/07/1985 Male 6 0 10 10 ## 6 6 09/07/1987 Male 6 2 11 12 ## 7 7 23/01/1995 Female 5 10 10 2 ## 8 8 31/12/1992 Male 6 3 12 1 ## 9 9 24/01/1952 Male 5 4 7 10 ## 10 10 11/06/1953 Female 5 2 8 6 ## # ... with 140 more rows The data type of Gender has switched to &lt;fct&gt;, which means it’s a factor. If we have a look at it, it’ll tell us the levels of that factor (i.e. what are all the possible values) head(dat_clean$Gender) #First few elements ## [1] Male Female Female Female Male Male ## Levels: Female Male Non-Binary head(as.numeric(dat_clean$Gender)) #This is what R sees ## [1] 2 1 1 1 2 2 levels(dat_clean$Gender) #This is what we see ## [1] &quot;Female&quot; &quot;Male&quot; &quot;Non-Binary&quot; In this version, “Female” has been chosen to be the first level. This means if we run any analysis, “Female” will be used as the reference category. This is because it’s the first element in the vector and so R just uses this by default. A lot of functions that can take a factor as an argument will automatically convert a character into a factor, and again, just use the first element as the reference. This might not be what we want, we might want “Male” to be our default, or if we run this on a different dataset in the same format, we might end up with a different default level. We we’re going to ensure that the “Female” category is our reference category using the relevel() function: dat_clean &lt;- dat %&gt;% mutate(ID = as.numeric(ID)) %&gt;% #Turn ID into numeric rename(Height = Ht, Weight = Wgt) %&gt;% #Rename some variables mutate(Gender = case_when(Gender %in% c(&quot;m&quot;,&quot;M&quot;,&quot;male&quot;) ~ &quot;Male&quot;, Gender %in% c(&quot;f&quot;,&quot;F&quot;,&quot;female&quot;) ~ &quot;Female&quot;, T ~ Gender) %&gt;% #Tidy up Gender factor %&gt;% relevel(&quot;Female&quot;)) levels(dat_clean$Gender) ## [1] &quot;Female&quot; &quot;Male&quot; &quot;Non-Binary&quot; Going forward, we’re not going to both using relevel() for now since we know our default is “Female”, but it’s useful to know. 2.4.9 The separate() function The Height &amp; Weight variables are still in an unusual form. From inspection, we can see that they’re written in imperial measures: feet &amp; inches and stone &amp; lbs. For Height, the feet &amp; inches are separated by a space, so we can use this to split the vector into two dat_clean &lt;- dat %&gt;% mutate(ID = as.numeric(ID)) %&gt;% #Turn ID into numeric rename(Height = Ht, Weight = Wgt) %&gt;% #Rename some variables mutate(Gender = case_when(Gender %in% c(&quot;m&quot;,&quot;M&quot;,&quot;male&quot;) ~ &quot;Male&quot;, Gender %in% c(&quot;f&quot;,&quot;F&quot;,&quot;female&quot;) ~ &quot;Female&quot;, T ~ Gender)) %&gt;% separate(Height,c(&quot;Feet&quot;,&quot;Inches&quot;),sep=&quot; &quot;) #Split Height up dat_clean ## # A tibble: 150 x 6 ## ID DOB Gender Feet Inches Weight ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 1 22/03/1965 Male 5 6 7 1 ## 2 2 17/04/1977 Female 5 9 11 0 ## 3 3 24/07/1966 Female 5 4 9 8 ## 4 4 22/02/1985 Female 5 7 11 1 ## 5 5 30/07/1985 Male 6 0 10 10 ## 6 6 09/07/1987 Male 6 2 11 12 ## 7 7 23/01/1995 Female 5 10 10 2 ## 8 8 31/12/1992 Male 6 3 12 1 ## 9 9 24/01/1952 Male 5 4 7 10 ## 10 10 11/06/1953 Female 5 2 8 6 ## # ... with 140 more rows This removes the Height variable and replaces it with two new ones, the Feet and Inches variables. We can now combine these back together by converting them into metres using the following conversion: 1 foot = 0.3048 m and 1 inch = 0.0254 m. dat_clean &lt;- dat %&gt;% mutate(ID = as.numeric(ID)) %&gt;% #Turn ID into numeric rename(Height = Ht, Weight = Wgt) %&gt;% #Rename some variables mutate(Gender = case_when(Gender %in% c(&quot;m&quot;,&quot;M&quot;,&quot;male&quot;) ~ &quot;Male&quot;, Gender %in% c(&quot;f&quot;,&quot;F&quot;,&quot;female&quot;) ~ &quot;Female&quot;, T ~ Gender)) %&gt;% separate(Height,c(&quot;Feet&quot;,&quot;Inches&quot;),sep=&quot; &quot;) %&gt;% #Split Height up mutate(Height = 0.3048*Feet + 0.0254*Inches) #Convert into metres ## Error in 0.3048 * Feet: non-numeric argument to binary operator We’ve hit our first error. Feet and Inches are still stored as characters. We need to convert them into Numbers before we can multiply and add them. We could do it this way: dat_clean &lt;- dat %&gt;% mutate(ID = as.numeric(ID)) %&gt;% #Turn ID into numeric rename(Height = Ht, Weight = Wgt) %&gt;% #Rename some variables mutate(Gender = case_when(Gender %in% c(&quot;m&quot;,&quot;M&quot;,&quot;male&quot;) ~ &quot;Male&quot;, Gender %in% c(&quot;f&quot;,&quot;F&quot;,&quot;female&quot;) ~ &quot;Female&quot;, T ~ Gender)) %&gt;% separate(Height,c(&quot;Feet&quot;,&quot;Inches&quot;),sep=&quot; &quot;) %&gt;% #Split Height up mutate(Feet = as.numeric(Feet), #Convert to Numbers Inches = as.numeric(Inches)) Which is easy enough, but what if we were wanting to do it with a lot of variables at once? 2.4.10 The mutate_at() function We can use the mutate_at() function to apply a function to a bunch of variables all at once. This is pretty advanced tidyverse stuff! dat_clean &lt;- dat %&gt;% mutate(ID = as.numeric(ID)) %&gt;% #Turn ID into numeric rename(Height = Ht, Weight = Wgt) %&gt;% #Rename some variables mutate(Gender = case_when(Gender %in% c(&quot;m&quot;,&quot;M&quot;,&quot;male&quot;) ~ &quot;Male&quot;, Gender %in% c(&quot;f&quot;,&quot;F&quot;,&quot;female&quot;) ~ &quot;Female&quot;, T ~ Gender)) %&gt;% separate(Height,c(&quot;Feet&quot;,&quot;Inches&quot;),sep=&quot; &quot;) %&gt;% #Split Height up mutate_at(c(&quot;Feet&quot;,&quot;Inches&quot;),as.numeric) #Convert to Numbers dat_clean ## # A tibble: 150 x 6 ## ID DOB Gender Feet Inches Weight ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 22/03/1965 Male 5 6 7 1 ## 2 2 17/04/1977 Female 5 9 11 0 ## 3 3 24/07/1966 Female 5 4 9 8 ## 4 4 22/02/1985 Female 5 7 11 1 ## 5 5 30/07/1985 Male 6 0 10 10 ## 6 6 09/07/1987 Male 6 2 11 12 ## 7 7 23/01/1995 Female 5 10 10 2 ## 8 8 31/12/1992 Male 6 3 12 1 ## 9 9 24/01/1952 Male 5 4 7 10 ## 10 10 11/06/1953 Female 5 2 8 6 ## # ... with 140 more rows This is a scoped version of the mutate() function, meaning that it mutates the tibble on a specific set of variables. We told the mutate_at() function that we want to apply the as.numeric() function to Feet and Inches. We passed the names of the variables as strings to mutate_at() and then passed the function without the brackets at the end. 2.4.11 The select() function We can now go back to the formula for converting feet/inches to metres and re-run it with Feet and Inches as numbers dat_clean &lt;- dat %&gt;% mutate(ID = as.numeric(ID)) %&gt;% #Turn ID into numeric rename(Height = Ht, Weight = Wgt) %&gt;% #Rename some variables mutate(Gender = case_when(Gender %in% c(&quot;m&quot;,&quot;M&quot;,&quot;male&quot;) ~ &quot;Male&quot;, Gender %in% c(&quot;f&quot;,&quot;F&quot;,&quot;female&quot;) ~ &quot;Female&quot;, T ~ Gender)) %&gt;% separate(Height,c(&quot;Feet&quot;,&quot;Inches&quot;),sep=&quot; &quot;) %&gt;% #Split Height up mutate_at(c(&quot;Feet&quot;,&quot;Inches&quot;),as.numeric) %&gt;% #Convert to Numbers mutate(Height = 0.3048*Feet + 0.0254*Inches) #Convert into metres dat_clean ## # A tibble: 150 x 7 ## ID DOB Gender Feet Inches Weight Height ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 22/03/1965 Male 5 6 7 1 1.68 ## 2 2 17/04/1977 Female 5 9 11 0 1.75 ## 3 3 24/07/1966 Female 5 4 9 8 1.63 ## 4 4 22/02/1985 Female 5 7 11 1 1.70 ## 5 5 30/07/1985 Male 6 0 10 10 1.83 ## 6 6 09/07/1987 Male 6 2 11 12 1.88 ## 7 7 23/01/1995 Female 5 10 10 2 1.78 ## 8 8 31/12/1992 Male 6 3 12 1 1.91 ## 9 9 24/01/1952 Male 5 4 7 10 1.63 ## 10 10 11/06/1953 Female 5 2 8 6 1.57 ## # ... with 140 more rows Almost done. We’ve now got Height into metres, but do we really need the Feet and Inches variables anymore? We can pick which variables we want to keep in our dataset using the select() function dat_clean &lt;- dat %&gt;% mutate(ID = as.numeric(ID)) %&gt;% #Turn ID into numeric rename(Height = Ht, Weight = Wgt) %&gt;% #Rename some variables mutate(Gender = case_when(Gender %in% c(&quot;m&quot;,&quot;M&quot;,&quot;male&quot;) ~ &quot;Male&quot;, Gender %in% c(&quot;f&quot;,&quot;F&quot;,&quot;female&quot;) ~ &quot;Female&quot;, T ~ Gender)) %&gt;% separate(Height,c(&quot;Feet&quot;,&quot;Inches&quot;),sep=&quot; &quot;) %&gt;% #Split Height up mutate_at(c(&quot;Feet&quot;,&quot;Inches&quot;),as.numeric) %&gt;% #Convert to Numbers mutate(Height = 0.3048*Feet + 0.0254*Inches) %&gt;% #Convert into metres select(ID,DOB,Gender,Height,Weight) #Pick just what we want to keep dat_clean ## # A tibble: 150 x 5 ## ID DOB Gender Height Weight ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 22/03/1965 Male 1.68 7 1 ## 2 2 17/04/1977 Female 1.75 11 0 ## 3 3 24/07/1966 Female 1.63 9 8 ## 4 4 22/02/1985 Female 1.70 11 1 ## 5 5 30/07/1985 Male 1.83 10 10 ## 6 6 09/07/1987 Male 1.88 11 12 ## 7 7 23/01/1995 Female 1.78 10 2 ## 8 8 31/12/1992 Male 1.91 12 1 ## 9 9 24/01/1952 Male 1.63 7 10 ## 10 10 11/06/1953 Female 1.57 8 6 ## # ... with 140 more rows Similar to working with vectors, we can also tell R which variables we don’t want. This might actually be easier here. dat_clean &lt;- dat %&gt;% mutate(ID = as.numeric(ID)) %&gt;% #Turn ID into numeric rename(Height = Ht, Weight = Wgt) %&gt;% #Rename some variables mutate(Gender = case_when(Gender %in% c(&quot;m&quot;,&quot;M&quot;,&quot;male&quot;) ~ &quot;Male&quot;, Gender %in% c(&quot;f&quot;,&quot;F&quot;,&quot;female&quot;) ~ &quot;Female&quot;, T ~ Gender)) %&gt;% separate(Height,c(&quot;Feet&quot;,&quot;Inches&quot;),sep=&quot; &quot;) %&gt;% #Split Height up mutate_at(c(&quot;Feet&quot;,&quot;Inches&quot;),as.numeric) %&gt;% #Convert to Numbers mutate(Height = 0.3048*Feet + 0.0254*Inches) %&gt;% #Convert into metres select(-Feet,-Inches) #Drop what we don&#39;t want dat_clean ## # A tibble: 150 x 5 ## ID DOB Gender Weight Height ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 22/03/1965 Male 7 1 1.68 ## 2 2 17/04/1977 Female 11 0 1.75 ## 3 3 24/07/1966 Female 9 8 1.63 ## 4 4 22/02/1985 Female 11 1 1.70 ## 5 5 30/07/1985 Male 10 10 1.83 ## 6 6 09/07/1987 Male 11 12 1.88 ## 7 7 23/01/1995 Female 10 2 1.78 ## 8 8 31/12/1992 Male 12 1 1.91 ## 9 9 24/01/1952 Male 7 10 1.63 ## 10 10 11/06/1953 Female 8 6 1.57 ## # ... with 140 more rows We’ve converted Height from feet and inches into metres. We still need to do the same for Weight into kg. The conversion between kg and st/lbs is 1 stone = 6.35029 kg and 1 lb = 0.453592 kg. Can you replicate what I did here for the Weight variable? Take Five minutes and have a think. Some functions that you run for this can be combined with the previous functions that we ran for Height. We also want to create a new variable, BMI, which is calculated as BMI = Weight/Height^2, let’s add this too! dat_clean &lt;- dat %&gt;% mutate(ID = as.numeric(ID)) %&gt;% #Turn ID into numeric rename(Height = Ht, Weight = Wgt) %&gt;% #Rename some variables mutate(Gender = case_when(Gender %in% c(&quot;m&quot;,&quot;M&quot;,&quot;male&quot;) ~ &quot;Male&quot;, Gender %in% c(&quot;f&quot;,&quot;F&quot;,&quot;female&quot;) ~ &quot;Female&quot;, T ~ Gender)) %&gt;% separate(Height,c(&quot;Feet&quot;,&quot;Inches&quot;),sep=&quot; &quot;) %&gt;% #Split Height up separate(Weight,c(&quot;Stone&quot;,&quot;Pounds&quot;),sep=&quot; &quot;) %&gt;% #Split Weight up mutate_at(c(&quot;Feet&quot;,&quot;Inches&quot;,&quot;Stone&quot;,&quot;Pounds&quot;),as.numeric) %&gt;% #Convert mutate(Height = 0.3048*Feet + 0.0254*Inches, Weight = 6.3502*Stone + 0.4535*Pounds, BMI = Weight/Height^2) %&gt;% #Convert into metres select(-Feet,-Inches,-Stone,-Pounds) #Drop what we don&#39;t want dat_clean ## # A tibble: 150 x 6 ## ID DOB Gender Height Weight BMI ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 22/03/1965 Male 1.68 44.9 16.0 ## 2 2 17/04/1977 Female 1.75 69.9 22.7 ## 3 3 24/07/1966 Female 1.63 60.8 23.0 ## 4 4 22/02/1985 Female 1.70 70.3 24.3 ## 5 5 30/07/1985 Male 1.83 68.0 20.3 ## 6 6 09/07/1987 Male 1.88 75.3 21.3 ## 7 7 23/01/1995 Female 1.78 64.4 20.4 ## 8 8 31/12/1992 Male 1.91 76.7 21.1 ## 9 9 24/01/1952 Male 1.63 49.0 18.5 ## 10 10 11/06/1953 Female 1.57 53.5 21.6 ## # ... with 140 more rows 2.4.12 Dates Dates are hard! This is just a fact. Leap Days, Time Zones, Daylight’s Savings Time, Leap Seconds. All make for difficulty in dealing with Dates. We’re going to need a specialised package for dates: lubridate. This is a package designed with the tidyverse in mind, but is not installed when we downloaded the tidyverse package at the start, so in the console, we’re going to install the lubridate package: install.packages(\"lubridate\"). As is convention (and keeping our code organised), we’re going to load the package into R using the library() function at the start of our code (rather than in the middle). library(lubridate) ## ## Attaching package: &#39;lubridate&#39; ## The following objects are masked from &#39;package:dplyr&#39;: ## ## intersect, setdiff, union ## The following objects are masked from &#39;package:base&#39;: ## ## date, intersect, setdiff, union This little info box just tells us that there is a function called date() in the base package and in the lubridate package. Since we’re loading the lubridate package, this essentially overwrites the date() function from the base package. Which is fine, since lubridate has a better version. We can still use the original date() function by writing base::date() (but we don’t need it). dat_clean &lt;- dat %&gt;% mutate(ID = as.numeric(ID)) %&gt;% #Turn ID into numeric rename(Height = Ht, Weight = Wgt) %&gt;% #Rename some variables mutate(Gender = case_when(Gender %in% c(&quot;m&quot;,&quot;M&quot;,&quot;male&quot;) ~ &quot;Male&quot;, Gender %in% c(&quot;f&quot;,&quot;F&quot;,&quot;female&quot;) ~ &quot;Female&quot;, T ~ Gender)) %&gt;% separate(Height,c(&quot;Feet&quot;,&quot;Inches&quot;),sep=&quot; &quot;) %&gt;% #Split Height up separate(Weight,c(&quot;Stone&quot;,&quot;Pounds&quot;),sep=&quot; &quot;) %&gt;% #Split Weight up mutate_at(c(&quot;Feet&quot;,&quot;Inches&quot;,&quot;Stone&quot;,&quot;Pounds&quot;),as.numeric) %&gt;% #Convert mutate(Height = 0.3048*Feet + 0.0254*Inches, Weight = 6.3502*Stone + 0.4535*Pounds, BMI = Weight/Height^2) %&gt;% #Convert into metres select(-Feet,-Inches,-Stone,-Pounds) %&gt;% #Drop what we don&#39;t want mutate(DOB = dmy(DOB)) # Convert Date dat_clean ## # A tibble: 150 x 6 ## ID DOB Gender Height Weight BMI ## &lt;dbl&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1965-03-22 Male 1.68 44.9 16.0 ## 2 2 1977-04-17 Female 1.75 69.9 22.7 ## 3 3 1966-07-24 Female 1.63 60.8 23.0 ## 4 4 1985-02-22 Female 1.70 70.3 24.3 ## 5 5 1985-07-30 Male 1.83 68.0 20.3 ## 6 6 1987-07-09 Male 1.88 75.3 21.3 ## 7 7 1995-01-23 Female 1.78 64.4 20.4 ## 8 8 1992-12-31 Male 1.91 76.7 21.1 ## 9 9 1952-01-24 Male 1.63 49.0 18.5 ## 10 10 1953-06-11 Female 1.57 53.5 21.6 ## # ... with 140 more rows The dmy() function takes in dates of the form “Day-Month-Year” and converts them into a type date. Pretty intuitive. There are similar functions such as mdy(), ymd() for different formats. These are all found in the same ?dmy Help file. The Date type functions similar to a number since it is considered a continuous variable, rather than a character, which makes it much easier to work with. For example, we can now sort them in order and find the median DOB, the dplyr package provides us with the median() function, which is an improvement on the quantile() function: median(dat_clean$DOB) ## [1] NA Oh, it’s returned NA, which means that there are NA values in our data. NA is usually used for Missing values. Let’s see how many we have. The is.na() function returns TRUE if the element in a vector is NA and FALSE if it isn’t (i.e. it contains an acutal number) dat_clean$DOB %&gt;% is.na %&gt;% sum ## [1] 5 A lot of functions also contain the option to ignore NA values, so let’s get the real median() median(dat_clean$DOB, na.rm=T) #na.rm=T tells median to remove the NAs ## [1] &quot;1978-03-11&quot; 2.4.13 The filter() function In our DOB variable, we have some NAs and they can really mess up our work. Let’s get rid of those entries using the filter() function. Remember that the ! (not) operator turns TRUE into FALSE and vice versa: dat_clean &lt;- dat %&gt;% mutate(ID = as.numeric(ID)) %&gt;% #Turn ID into numeric rename(Height = Ht, Weight = Wgt) %&gt;% #Rename some variables mutate(Gender = case_when(Gender %in% c(&quot;m&quot;,&quot;M&quot;,&quot;male&quot;) ~ &quot;Male&quot;, Gender %in% c(&quot;f&quot;,&quot;F&quot;,&quot;female&quot;) ~ &quot;Female&quot;, T ~ Gender)) %&gt;% separate(Height,c(&quot;Feet&quot;,&quot;Inches&quot;),sep=&quot; &quot;) %&gt;% #Split Height up separate(Weight,c(&quot;Stone&quot;,&quot;Pounds&quot;),sep=&quot; &quot;) %&gt;% #Split Weight up mutate_at(c(&quot;Feet&quot;,&quot;Inches&quot;,&quot;Stone&quot;,&quot;Pounds&quot;),as.numeric) %&gt;% #Convert mutate(Height = 0.3048*Feet + 0.0254*Inches, Weight = 6.3502*Stone + 0.4535*Pounds, BMI = Weight/Height^2) %&gt;% #Convert into metres select(-Feet,-Inches,-Stone,-Pounds) %&gt;% #Drop what we don&#39;t want mutate(DOB = dmy(DOB)) %&gt;% # Convert Date filter(!is.na(DOB)) #Get rid of the NAs dat_clean ## # A tibble: 145 x 6 ## ID DOB Gender Height Weight BMI ## &lt;dbl&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1965-03-22 Male 1.68 44.9 16.0 ## 2 2 1977-04-17 Female 1.75 69.9 22.7 ## 3 3 1966-07-24 Female 1.63 60.8 23.0 ## 4 4 1985-02-22 Female 1.70 70.3 24.3 ## 5 5 1985-07-30 Male 1.83 68.0 20.3 ## 6 6 1987-07-09 Male 1.88 75.3 21.3 ## 7 7 1995-01-23 Female 1.78 64.4 20.4 ## 8 8 1992-12-31 Male 1.91 76.7 21.1 ## 9 9 1952-01-24 Male 1.63 49.0 18.5 ## 10 10 1953-06-11 Female 1.57 53.5 21.6 ## # ... with 135 more rows Now we’ve completely got rid of the NAs in our dataset and should have values for every cell. 2.4.14 The summarise() function Now we have a bunch of tidy data, what can we do with it? Well firstly, we can grab out some important descriptive statistics. Previously, we have used things like the mean() and sd() functions on vectors and we can do that here within our tibble. What happens if we do it in a mutate() call? dat_clean &lt;- dat %&gt;% mutate(ID = as.numeric(ID)) %&gt;% #Turn ID into numeric rename(Height = Ht, Weight = Wgt) %&gt;% #Rename some variables mutate(Gender = case_when(Gender %in% c(&quot;m&quot;,&quot;M&quot;,&quot;male&quot;) ~ &quot;Male&quot;, Gender %in% c(&quot;f&quot;,&quot;F&quot;,&quot;female&quot;) ~ &quot;Female&quot;, T ~ Gender)) %&gt;% separate(Height,c(&quot;Feet&quot;,&quot;Inches&quot;),sep=&quot; &quot;) %&gt;% #Split Height up separate(Weight,c(&quot;Stone&quot;,&quot;Pounds&quot;),sep=&quot; &quot;) %&gt;% #Split Weight up mutate_at(c(&quot;Feet&quot;,&quot;Inches&quot;,&quot;Stone&quot;,&quot;Pounds&quot;),as.numeric) %&gt;% #Convert mutate(Height = 0.3048*Feet + 0.0254*Inches, Weight = 6.3502*Stone + 0.4535*Pounds, BMI = Weight/Height^2) %&gt;% #Convert into metres select(-Feet,-Inches,-Stone,-Pounds) %&gt;% #Drop what we don&#39;t want mutate(DOB = dmy(DOB)) %&gt;% # Convert Date filter(!is.na(DOB)) %&gt;% #Get rid of the NAs mutate(mean.BMI = mean(BMI)) dat_clean ## # A tibble: 145 x 7 ## ID DOB Gender Height Weight BMI mean.BMI ## &lt;dbl&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1965-03-22 Male 1.68 44.9 16.0 20.5 ## 2 2 1977-04-17 Female 1.75 69.9 22.7 20.5 ## 3 3 1966-07-24 Female 1.63 60.8 23.0 20.5 ## 4 4 1985-02-22 Female 1.70 70.3 24.3 20.5 ## 5 5 1985-07-30 Male 1.83 68.0 20.3 20.5 ## 6 6 1987-07-09 Male 1.88 75.3 21.3 20.5 ## 7 7 1995-01-23 Female 1.78 64.4 20.4 20.5 ## 8 8 1992-12-31 Male 1.91 76.7 21.1 20.5 ## 9 9 1952-01-24 Male 1.63 49.0 18.5 20.5 ## 10 10 1953-06-11 Female 1.57 53.5 21.6 20.5 ## # ... with 135 more rows We now have the average BMI in every row. Maybe that’s what we wanted. But it’s not what I wanted. Let’s put it in a summarise() call instead. Since we’ve neatened up our dat_clean dataset as much as possible, we’re going to save it and edit from there dat_clean &lt;- dat %&gt;% mutate(ID = as.numeric(ID)) %&gt;% #Turn ID into numeric rename(Height = Ht, Weight = Wgt) %&gt;% #Rename some variables mutate(Gender = case_when(Gender %in% c(&quot;m&quot;,&quot;M&quot;,&quot;male&quot;) ~ &quot;Male&quot;, Gender %in% c(&quot;f&quot;,&quot;F&quot;,&quot;female&quot;) ~ &quot;Female&quot;, T ~ Gender)) %&gt;% separate(Height,c(&quot;Feet&quot;,&quot;Inches&quot;),sep=&quot; &quot;) %&gt;% #Split Height up separate(Weight,c(&quot;Stone&quot;,&quot;Pounds&quot;),sep=&quot; &quot;) %&gt;% #Split Weight up mutate_at(c(&quot;Feet&quot;,&quot;Inches&quot;,&quot;Stone&quot;,&quot;Pounds&quot;),as.numeric) %&gt;% #Convert mutate(Height = 0.3048*Feet + 0.0254*Inches, Weight = 6.3502*Stone + 0.4535*Pounds, BMI = Weight/Height^2) %&gt;% #Convert into metres select(-Feet,-Inches,-Stone,-Pounds) %&gt;% #Drop what we don&#39;t want mutate(DOB = dmy(DOB)) %&gt;% # Convert Date filter(!is.na(DOB)) #Get rid of the NAs dat_clean %&gt;% summarise(mean.BMI = mean(BMI)) ## # A tibble: 1 x 1 ## mean.BMI ## &lt;dbl&gt; ## 1 20.5 Well, that’s a bit better, but what if we want more than just the mean of the BMI? Let’s over-complicated this summarise() function dat_clean %&gt;% summarise_at(c(&quot;Height&quot;,&quot;Weight&quot;,&quot;BMI&quot;), list(mean=mean,sd=sd,min=min,max=max)) ## # A tibble: 1 x 12 ## Height_mean Weight_mean BMI_mean Height_sd Weight_sd BMI_sd Height_min ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1.70 59.5 20.5 0.0943 14.6 4.24 1.47 ## # ... with 5 more variables: Weight_min &lt;dbl&gt;, BMI_min &lt;dbl&gt;, Height_max &lt;dbl&gt;, ## # Weight_max &lt;dbl&gt;, BMI_max &lt;dbl&gt; Within the summarise_at() function, we’ve created a list() of functions and told R to perform that function on all of the variables we gave it. Very similar to the way we used mutate_at() earlier. 2.4.15 The group_by() function It’s all very well having a summary of the entire dataset, but what if I want to stratify. I want the same statistics, but based on a the value in Gender. Easy. Peasy. dat_clean %&gt;% group_by(Gender) #Group the data ## # A tibble: 145 x 6 ## # Groups: Gender [3] ## ID DOB Gender Height Weight BMI ## &lt;dbl&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1965-03-22 Male 1.68 44.9 16.0 ## 2 2 1977-04-17 Female 1.75 69.9 22.7 ## 3 3 1966-07-24 Female 1.63 60.8 23.0 ## 4 4 1985-02-22 Female 1.70 70.3 24.3 ## 5 5 1985-07-30 Male 1.83 68.0 20.3 ## 6 6 1987-07-09 Male 1.88 75.3 21.3 ## 7 7 1995-01-23 Female 1.78 64.4 20.4 ## 8 8 1992-12-31 Male 1.91 76.7 21.1 ## 9 9 1952-01-24 Male 1.63 49.0 18.5 ## 10 10 1953-06-11 Female 1.57 53.5 21.6 ## # ... with 135 more rows We can tell R that we want the rows in our tibble to be grouped together based on the value in the Gender variable. Now, the summarise() function will respect this grouping. dat_clean %&gt;% group_by(Gender) %&gt;% #Group the data summarise_at(c(&quot;Height&quot;,&quot;Weight&quot;,&quot;BMI&quot;), list(mean=mean,sd=sd,min=min,max=max)) ## # A tibble: 3 x 13 ## Gender Height_mean Weight_mean BMI_mean Height_sd Weight_sd BMI_sd Height_min ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Female 1.65 55.2 20.3 0.0764 12.8 4.16 1.47 ## 2 Male 1.76 64.5 20.8 0.0785 15.2 4.40 1.55 ## 3 Non-B~ 1.62 54.1 20.6 0.0381 9.40 3.14 1.57 ## # ... with 5 more variables: Weight_min &lt;dbl&gt;, BMI_min &lt;dbl&gt;, Height_max &lt;dbl&gt;, ## # Weight_max &lt;dbl&gt;, BMI_max &lt;dbl&gt; 2.5 Combining data Quite often in our data analysis, we will need to combine data from multiple sources into a single dataset. For example, we might have taken scoring measurements separately and want to combine them back in with our original anthropometric data above. 2.5.1 The *_join() functions We can do that with the family of *_join() functions. These functions take two tibbles (or data.frames), x and y and joins them together based on an identifier for each row. However, sometimes we may have an id that is in one dataset, but not in the other. The *_join() family allows us to decide what entries to keep. inner_join() will keep only the IDs that appear in both x and y. full_join() will keep all IDs from both and if there are any missing, it will replace them with an NA. left_join() and right_join() will keep all of the IDs in the left (x) or the right (x) regardless of whether they’re in the other or not. Let’s bring in a new dataset and try it out! dat_score &lt;- read_csv(&quot;data/data_score.csv&quot;, col_types=cols()) dat_score ## # A tibble: 150 x 4 ## ID Score_1 Score_2 Score_3 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 68.2 81.0 88.8 ## 2 2 42.8 56.2 72.1 ## 3 3 45.1 56.6 63.7 ## 4 4 59.3 64.9 63.5 ## 5 5 52.3 49.8 54.4 ## 6 6 63.5 68.2 79.9 ## 7 7 32.5 40.3 52.3 ## 8 8 32.2 42.2 56.5 ## 9 9 59.2 62.6 75.7 ## 10 10 38.9 41.5 50.8 ## # ... with 140 more rows This dataset has the same ID as our previous one, but don’t forget we previously deleted some rows from our dataset (based on whether DOB was missing or not). So we don’t have the exact same ones. This means we’re going to want to use inner_join()? We need to pass the datasets as arguments along with a vector telling R which variables are our identifiers: dat_joined &lt;- inner_join(dat_clean,dat_score,by=&quot;ID&quot;) dat_joined ## # A tibble: 145 x 9 ## ID DOB Gender Height Weight BMI Score_1 Score_2 Score_3 ## &lt;dbl&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1965-03-22 Male 1.68 44.9 16.0 68.2 81.0 88.8 ## 2 2 1977-04-17 Female 1.75 69.9 22.7 42.8 56.2 72.1 ## 3 3 1966-07-24 Female 1.63 60.8 23.0 45.1 56.6 63.7 ## 4 4 1985-02-22 Female 1.70 70.3 24.3 59.3 64.9 63.5 ## 5 5 1985-07-30 Male 1.83 68.0 20.3 52.3 49.8 54.4 ## 6 6 1987-07-09 Male 1.88 75.3 21.3 63.5 68.2 79.9 ## 7 7 1995-01-23 Female 1.78 64.4 20.4 32.5 40.3 52.3 ## 8 8 1992-12-31 Male 1.91 76.7 21.1 32.2 42.2 56.5 ## 9 9 1952-01-24 Male 1.63 49.0 18.5 59.2 62.6 75.7 ## 10 10 1953-06-11 Female 1.57 53.5 21.6 38.9 41.5 50.8 ## # ... with 135 more rows 2.5.2 The pivot_*()functions So we have the scores in what is known as a wide format, the table has a lot of columns and each score (1-3) has it’s own column. We can change this into a long format, where each ID x Score combination has it’s own row: dat_joined %&gt;% pivot_longer(c(Score_1,Score_2,Score_3), names_to=&quot;ScoreNum&quot;, values_to=&quot;Score&quot;, names_prefix=&quot;Score_&quot;) ## # A tibble: 435 x 8 ## ID DOB Gender Height Weight BMI ScoreNum Score ## &lt;dbl&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 1965-03-22 Male 1.68 44.9 16.0 1 68.2 ## 2 1 1965-03-22 Male 1.68 44.9 16.0 2 81.0 ## 3 1 1965-03-22 Male 1.68 44.9 16.0 3 88.8 ## 4 2 1977-04-17 Female 1.75 69.9 22.7 1 42.8 ## 5 2 1977-04-17 Female 1.75 69.9 22.7 2 56.2 ## 6 2 1977-04-17 Female 1.75 69.9 22.7 3 72.1 ## 7 3 1966-07-24 Female 1.63 60.8 23.0 1 45.1 ## 8 3 1966-07-24 Female 1.63 60.8 23.0 2 56.6 ## 9 3 1966-07-24 Female 1.63 60.8 23.0 3 63.7 ## 10 4 1985-02-22 Female 1.70 70.3 24.3 1 59.3 ## # ... with 425 more rows The effects of pivot_longer() can be undone with the pivot_wider() function dat_joined %&gt;% pivot_longer(c(Score_1,Score_2,Score_3), names_to=&quot;ScoreNum&quot;, values_to=&quot;Score&quot;, names_prefix=&quot;Score_&quot;) %&gt;% pivot_wider(names_from=ScoreNum, values_from=Score, names_prefix=&quot;Score_&quot;) ## # A tibble: 145 x 9 ## ID DOB Gender Height Weight BMI Score_1 Score_2 Score_3 ## &lt;dbl&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1965-03-22 Male 1.68 44.9 16.0 68.2 81.0 88.8 ## 2 2 1977-04-17 Female 1.75 69.9 22.7 42.8 56.2 72.1 ## 3 3 1966-07-24 Female 1.63 60.8 23.0 45.1 56.6 63.7 ## 4 4 1985-02-22 Female 1.70 70.3 24.3 59.3 64.9 63.5 ## 5 5 1985-07-30 Male 1.83 68.0 20.3 52.3 49.8 54.4 ## 6 6 1987-07-09 Male 1.88 75.3 21.3 63.5 68.2 79.9 ## 7 7 1995-01-23 Female 1.78 64.4 20.4 32.5 40.3 52.3 ## 8 8 1992-12-31 Male 1.91 76.7 21.1 32.2 42.2 56.5 ## 9 9 1952-01-24 Male 1.63 49.0 18.5 59.2 62.6 75.7 ## 10 10 1953-06-11 Female 1.57 53.5 21.6 38.9 41.5 50.8 ## # ... with 135 more rows These two functions work really well together depending on how we want our data to look. How we want our data to look will usually depend on what analysis we are doing. 2.6 The Cheat Sheets We’ve introduced a bunch of new functions throughout this lesson and mentioned quite a few different packages. The Reference manuals and vignettes from a package can be incredibly useful for a thorough description of how the package works. But, a more intuitive resource is the RStudio Cheatsheets. These are much more visual and are really useful as a lookup if you can’t quite remember what function you need to use (rather than trawling through the Reference manual). Not all Cheatsheets are on the RStudio page, but remember, Google is your friend and searching specifically for Cheatsheets is easy! For example: “R dplyr Cheatsheet” There is also a shortcut to some of these Cheatsheets within RStudio in the menubar (at the top of the window) Help &gt; Cheatsheets Let’s take a look at the dplyr Cheatsheet! We can find this in the Help shortcut in R Studio. "],
["how-do-i-look.html", "3 How Do I Look? 3.1 The ggplot() function 3.2 The aes() function 3.3 The geom_point() function 3.4 The geom_line() function 3.5 The geom_histogram() function 3.6 The geom_density() function 3.7 The geom_bar() function 3.8 Long vs Wide 3.9 The geom_ribbon() function 3.10 Zooming 3.11 Labelling 3.12 Other aesthetics 3.13 The ggsave() function", " 3 How Do I Look? One of the most pleasing packages that comes with the tidyverse is the ggplot2 package. This is at the core of plotting within the tidyverse. As with anything else in R, there are other package that can plot that are built on top of the ggplot2 package. Once we learn the core style of ggplot2, you’ll be able to transfer that knowledge. 3.1 The ggplot() function Previously we made plots using the plot() function, which takes an x and y and plots them together. Pretty intuitive. For ggplot(), our data needs to be organised into a tibble (or a data.frame) for us to actually plot it. This is why we’re going to need the tibble() function, because our data needs structure before we can ggplot() it. The ggplot() function basically just starts us off. Like grabbing a blank canvas. We’ll then add layers to our canvas using other functions. Try running ggplot() on it’s own and you’ll see that it clears the Plots tab in our Viewer pane. 3.2 The aes() function There are lots of different aspects of a plot that we can change and personalise. This includes the values that we’re going to put along the x- and y-axis. In ggplot2, we call these things aesthetics. We use the aes() function to map variables in our dataset (a tibble or a data.frame) to these aesthetics: aes(Score_1,Score_2,col=Score_3) ## Aesthetic mapping: ## * `x` -&gt; `Score_1` ## * `y` -&gt; `Score_2` ## * `colour` -&gt; `Score_3` Notice that we haven’t provided any data to aes(). We’ve just provided it with some variable names (without quotes). When we do tell ggplot2 what our data is, it will automatically piece it all together based on these mappings. Also note that aes() assumes the first two arguments are x and y (unless otherwise stated). Convenient. Now, whenever we want to do something with our data in ggplot2, we use these aesthetics, rather than the original variable names. 3.3 The geom_point() function So now ggplot2 knows what our variables are called, so let’s tell it how we want to display our variables. The simplest plot we can do is a geom_point() plot, which gives us a scatter plot. Remember, we start with blank canvas ggplot() and then add our layers to it. n &lt;- 50 dat &lt;- tibble(Score_1 = rnorm(n),Score_2 = rnorm(n), Score_3 = rnorm(n)) ggplot(dat,aes(Score_1,Score_2)) + geom_point() In this code, we defined our data and our aesthetics in the ggplot() function. This means that we’re going to use the same data and aesthetics for each layer, but we can specify either the data or the aesthetics for an individual layer, and we can specify aesthetics separately. ggplot(aes(x=Score_1),data=dat) + geom_point(aes(y=Score_2),col=&quot;red&quot;) + geom_point(aes(y=Score_3),col=&quot;blue&quot;) We can also define aesthetics to be separate from the data. In the above example, we defined col (or colour) to be a constant for each layer individually. Therefore, this is a static aesthetic (since it doesn’t change) as opposed to a dynamic aesthetic (different for each data point). 3.4 The geom_line() function The previous function allowed us to plot a scatter plot. Nice and basic. Obviously, there are plenty of other kinds of plots we might want to create. The key aspects of these functions stays the same, but we can change what the type of plot is by changing what comes after the geom_* dat_lin &lt;- tibble(Score_1 = seq(-3,3,length.out=20), Score_2 = Score_1+rnorm(20,sd=0.3)) ggplot(aes(x=Score_1,y=Score_2),data=dat) + geom_point(col=&quot;red&quot;) + geom_line(data=dat_lin) Notice that here, we have specified that the data in our geom_line() function is acutally going to come from a different dataset to our geom_point() function. By default, the functions will use the data and aesthetics defined in the ggplot() function, but we can override that if we want to add more to our plots. It’s also important to remember that ggplot2 is adding the layers to our canvas in order, so sometimes we may end up with a layer being over another. 3.5 The geom_histogram() function If we have a single variable and we want to see it’s distribution, the most common way to do this is through a histogram and, of course, ggplot2 has a histogramming function: p &lt;- ggplot(dat, aes(Score_1)) + geom_histogram(aes(y=..density..),binwidth=0.2,fill=&quot;red&quot;) p Note that here, we actually stored our plot as a variable, p. This can be useful if you want to experiment with different styles in your plot without having to re-write the whole ggplot() command. We also supplied the x aesthetic (Score_1), which is what we’re counting and the y=..density.. aesthetic. This tells ggplot2 to show the density of the bins, rather than the count data. We’re also passing two other arguments to the geom_histogram() function. The binwidth=0.2 tells geom_histogram() how wide we want each of these bins to be. There are various other ways we can define this and by default geom_histogram() will create 30 equally spaced bins. The fill argument tells geom_histogram() what colour to fill the bars in, whereas the col argument used earlier would tell geom_histogram() what colour to draw the border of our shapes. 3.6 The geom_density() function Creating a histogram is a nice way to see the distribution, but we can add a smoother version of a histogram using geom_density(), which essentially smooths out this distribution to look more like our classic density functions which define our pdfs: p + geom_density() 3.7 The geom_bar() function The histogram cuts our x-axis into bins and count how many values are in each of these bins. If we’re using categorical variables, we need a bar chart rather than a histogram. c(&quot;dog&quot;,&quot;cat&quot;,&quot;fish&quot;) %&gt;% sample(30,replace=T) %&gt;% tibble(cat=.) %&gt;% ggplot(aes(cat)) + geom_bar(aes(fill=cat)) Notice that we have integrated our ggplot() function with the %&gt;% to funnel our transformed dataset directly into our plot, and then added on the layers as normal. This is why ggplot() takes the dataset as it’s first argument. 3.8 Long vs Wide In the previous lesson we briefly touched on the gather() and spread() functions as a way to convert between Long and Wide formatted data. Let’s take a look at two different ways to plot the same data: n &lt;- 20 dat_lin &lt;- tibble(time = 1:n, Score_1 = time + rnorm(n), Score_2 = 0.3*time + rnorm(n), Score_3 = 1.2*time + rnorm(n,sd=0.3), Score_4 = 0.5*time + rnorm(n,sd=0.3), Score_5 = 2*time + rnorm(n,sd=0.3)) ggplot(dat_lin,aes(x=time)) + geom_line(aes(y=Score_1),col=&quot;black&quot;) + geom_line(aes(y=Score_2),col=&quot;red&quot;) + geom_line(aes(y=Score_3),col=&quot;blue&quot;) + geom_line(aes(y=Score_4),col=&quot;orange&quot;)+ geom_line(aes(y=Score_5),col=&quot;purple&quot;) Here, our data is in a Wide format, meaning we have a separate column for each of our variables. The code above works okay, but if we have a lot of these variables in our wide format, then we’d be typing the same code repeatedly and creating a new layer for each variable (and we made run out of colours to come up with!) dat_lin %&gt;% gather(-time,key=&quot;Score.Num&quot;,value=&quot;Score&quot;) %&gt;% ggplot(aes(x=time)) + geom_line(aes(y=Score,group=Score.Num,col=Score.Num)) This method bypassess the need to come up with our own colours for our lines (ggplot2 has some built in methods of picking colours) and also provides a legend along the side to tel us what each colour means. 3.9 The geom_ribbon() function In statistics, we’re never sure that an estimate is exact, and so a common thing that we would do is to estimate it within some sort of boundary. If we have these bounds, we can use them in a plot: dat &lt;- tibble(time = 1:20, Score = time + rnorm(20), Error = runif(20,0,1)) dat %&gt;% mutate(Upper = Score + Error, Lower = Score - Error) %&gt;% ggplot(aes(x=time)) + geom_line(aes(y=Score),col=&quot;red&quot;) + geom_ribbon(aes(ymin=Lower,ymax=Upper),col=NA,fill=&quot;red&quot;,alpha=0.2) In the above plot, we used a static aesthetic called alpha, this defines how transparent our ribbon is and means that we can still see the other layer below it (remember ggplot2 plots the layers in order). Worth noting that we don’t necessarily have to define the confidence intervals before plotting the data. We can pass calculations as aesthetics. ggplot(dat,aes(x=time)) + geom_line(aes(y=Score),col=&quot;red&quot;) + geom_ribbon(aes(ymin=Score-Error,ymax=Score + Error),col=NA,fill=&quot;red&quot;,alpha=0.2) 3.10 Zooming By deafult, ggplot2 will figure out what the range of values your data is using and create the plot accordingly to include all of your data. However, sometimes this is not idea n &lt;- 30 dat &lt;- tibble(time = 1:n, Score = rnorm(n)) #Let&#39;s deliberately add in an outlier dat$Score[15] &lt;- 100 p &lt;- ggplot(dat,aes(time,Score)) + geom_line() p See, all of the data is really clumped together and it makes it hard to see because of that one outlier, ggplot tries to plot everything. We can use ylim() or it’s counterpart, xlim() to zoom in on the region that we only way to consider. p + ylim(-3,3) This view creates a cut along our line. If we were plotting points, this would be fine or if we did want to omit the outlier, it would work okay. But what if we just want to zoom in, but keep the outlier off-screen? We use coord_cartesian() to do this. p + coord_cartesian(ylim=c(-3,3)) The graph is essentially the same, but we’ve zoomed in and the lines still all connect. 3.11 Labelling Up until now, we’ve been plotting pretty plain views of the data, however we’d usually want our plots to be clear about what they’re showing: n &lt;- 40 dat &lt;- tibble(yr = 1970 + 1:n, v = rnorm(n)) p &lt;- ggplot(dat,aes(yr,v)) + geom_line() p + labs(title=&quot;Change over time&quot;, subtitle = &quot;Right Here&quot;, x = &quot;Year&quot;, y = &quot;Score&quot;) 3.12 Other aesthetics We mentioned briefly that we could change the colour of our points, either as a static change (everything in the layer is the same) or based on a group. There are a few other aesthetics we can personalise as we like: n &lt;- 100 dat &lt;- tibble(Main = sample(c(&quot;Pizza&quot;,&quot;Pasta&quot;,&quot;Steak&quot;),n,replace=T), Dessert = sample(c(&quot;Ice Cream&quot;,&quot;Cake&quot;,&quot;Biscuits&quot;),n,replace=T), Helpings = sample(4,n,replace=T), Age = rnorm(n,40,10), Score = rnorm(n,20,5)) p &lt;- ggplot(dat) + geom_point(aes(x=Age,y=Score,col=Main,shape=Dessert,size=Helpings)) p 3.13 The ggsave() function So, we’ve made our beautiful plot. What do we do with it now? We need to be able to save it! the ggsave() function does just that ggsave(&quot;MyPlot.jpg&quot;,p) ## Saving 7 x 5 in image Here is the saved image: When we save, we can either do it as default "]
]
